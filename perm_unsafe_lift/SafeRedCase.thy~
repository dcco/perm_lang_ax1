theory SafeRedCase
  imports WTLemma ReduceRestrX ReduceWTS SRUseEnv
begin 
  
  (* ###### case lemmas *)    

lemma safe_app_op_case: "\<lbrakk> app_red_exp OpApp (s1, AppExp (OpExp xop) v) ax (s2, e2); FunTy tx tau r a = op_type xop \<rbrakk> \<Longrightarrow> well_typed env r_s1 e2 tau r_s1 empty_use_env"
  apply (case_tac v)
       apply (auto)
  apply (case_tac ax)
   apply (auto)
    (* given xop: op, x1: const, assuming tau matches the return type of xop, we want to show that e2 is well-typed.
        now e2 can either be an op or a const.
    *)
  apply (case_tac "\<not> (\<exists> rop. e2 = OpExp rop)")
   apply (case_tac "\<not> (\<exists> c. e2 = ConstExp c)")
    apply (auto)
        apply (case_tac xop)
             apply (auto)
    (* the hard part is proving that e2 will have the right type. *)
       apply (case_tac xop)
            apply (auto)
         apply (simp add: pure_fun_def)
        apply (simp add: pure_fun_def)
       apply (simp add: pure_fun_def)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac leq_empty_use_env)
    (* op case, same thing *)
    apply (case_tac xop)
         apply (auto)
      apply (simp add: pure_fun_def)
     apply (simp add: pure_fun_def)
    apply (simp add: pure_fun_def)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac leq_empty_use_env)
  done  

lemma well_typed_state_add_vars: "\<lbrakk> well_typed_state s1 env rs_map; fresh_var s1 x; well_typed_mem_value env r_s tau v; proper_mem_value rs_map v;
  sub_use_env s1 r_s; sep_nres_map r_s (rem_env rs_map x) \<rbrakk> \<Longrightarrow> well_typed_state (add_env s1 x v) (add_env env x tau) (add_env rs_map x r_s)"
    (* starts by proving the validity of the env + res map *)
  apply (simp add: well_typed_state_def)
  apply (auto)
    apply (rule_tac dist_add_sub_env)
    apply (simp)
   apply (simp add: valid_nres_map_def)
   apply (auto)
    (* the state is still fully covered by the map *)
     apply (simp add: full_nres_map_def)
     apply (auto)
      apply (simp add: add_env_def)
      apply (auto)
     apply (simp add: add_env_def)
     apply (auto)
    (* prove disjointness remains *)
    apply (rule_tac disj_add_nres_map)
     apply (auto)
    (* prove containment remains *)
   apply (rule_tac add_sub_nres_map2)
    apply (rule_tac add_sub_nres_map1)
     apply (simp_all)
   apply (simp add: fresh_var_def)
    (* now it remains to prove that all the values are still well-typed. we do the x = xa case first *)
  apply (erule_tac x="xa" in allE)
  apply (case_tac "x = xa")
   apply (case_tac "add_env s1 x v x")
    apply (simp add: add_env_def)
   apply (auto)
   apply (case_tac "add_env env x tau x")
    apply (simp add: add_env_def)
   apply (auto)
   apply (cut_tac rs_map="rs_map" and x="x" and r_s="r_s" in nres_add_same)
   apply (simp)
   apply (rule_tac well_typed_mv_add_vars)
    apply (simp add: add_env_def)
   apply (simp add: fresh_var_def)
    apply (simp add: sub_env_def)
    (* proper mem value *)
   apply (rule_tac proper_add_mv)
    apply (simp add: add_env_def)
   apply (simp add: nres_lookup_def)
   apply (simp add: valid_nres_map_def)
   apply (simp add: full_nres_map_def)
   apply (simp add: fresh_var_def)
   apply (rule_tac leq_empty_use_env)
    (* now we do that x \<noteq> xa case *)
  apply (simp add: add_env_def)
  apply (case_tac "s1 xa")
   apply (auto)
  apply (simp add: add_env_def)
  apply (case_tac "env xa")
   apply (auto)
  apply (cut_tac rs_map="rs_map" and x="x" and r_s="r_s" and y="xa" in nres_add_diff)
   apply (simp_all)
  apply (rule_tac well_typed_mv_add_vars)
   apply (auto)
  apply (simp add: fresh_var_def)
   apply (simp add: sub_env_def)
    (* properness *)
  apply (rule_tac proper_add_mv)
   apply (simp)
  apply (simp add: fresh_var_def)
  apply (simp add: valid_nres_map_def)
  apply (simp add: full_nres_map_def)
  apply (simp add: nres_lookup_def)
  apply (rule_tac leq_empty_use_env)
  done    
    
    (* this lemma states that given a well-typed state, adding x simultaneously to the state, env, rs_map should yield another well-typed state.  *)(*
lemma well_typed_state_add_vars: "\<lbrakk> well_typed_state s1 env rs_map; fresh_var s1 x; well_typed_mem_value s1 env (intro_use_env empty_use_env cs) tau v;
  scope_use_env rs_map (intro_use_env empty_use_env cs)(*; sep_res_map (intro_use_env empty_use_env cs) rs_map*) \<rbrakk> \<Longrightarrow>
  well_typed_state (add_env s1 x v) (add_env env x tau) (add_mem rs_map x (intro_use_env empty_use_env cs))"
    (* starts by proving the validity of the env + res map *)
  apply (simp add: well_typed_state_def)
  apply (auto)
    apply (rule_tac dist_add_sub_env)
    apply (simp)
   apply (simp add: valid_res_map_def)
   apply (auto)(*
     apply (rule_tac disj_add_res_map)
      apply (auto)*)
    apply (rule_tac add_sub_res_map)
    apply (auto)
   apply (rule_tac add_scope_res_map)
     apply (auto)
   apply (simp add: fresh_var_def)
   apply (simp add: sub_res_map_def)
   apply (simp add: fresh_map_var_def)
    (* now it remains to prove that all the values are still well-typed. we do the x = xa case first *)
  apply (erule_tac x="xa" in allE)
  apply (case_tac "x = xa")
   apply (case_tac "add_env s1 x v x")
    apply (simp add: add_env_def)
   apply (auto)
   apply (case_tac "add_env env x tau x")
    apply (simp add: add_env_def)
   apply (auto)
   apply (simp add: lookup_res_def)
   apply (simp add: add_mem_def)
   apply (rule_tac well_typed_mv_add_vars)
    apply (rule_tac well_typed_mv_add_env)
      apply (simp add: add_env_def)
     apply (auto)
   apply (simp add: fresh_var_def)
   apply (simp add: sub_env_def)
    (* now we do that x \<noteq> xa case *)
  apply (simp add: add_env_def)
  apply (case_tac "s1 xa")
   apply (auto)
  apply (simp add: add_env_def)
  apply (case_tac "env xa")
   apply (auto)
  apply (simp add: lookup_res_def)
  apply (simp add: add_mem_def)
  apply (rule_tac well_typed_mv_add_vars)
   apply (rule_tac well_typed_mv_add_env)
     apply (auto)
  apply (simp add: fresh_var_def)
  apply (simp add: sub_env_def)
  done*)
    
lemma sacc_make_act_case: "
        \<lbrakk>well_typed_state s1 env rs_map; app_red_exp ConstApp (s1, AppExp (ConstExp c) v) (MakeAct x) (s2, e2); valid_exp_use_env s1 rs_map r_f;
                well_typed env r_s1 v t1 r_s2 rx2; leq_use_env r_s3 (diff_use_env r_s2 (comp_use_env rx1 (lift_use_env rx2 r))); leq_use_env rx r_s3;
                FunTy t1 t2 r a \<in> const_type c; c \<noteq> FixConst; ax = MakeAct x; leq_use_env r_s1 r_f\<rbrakk>
               \<Longrightarrow> well_typed (add_env env x t2) (add_use_env r_s1 x OwnPerm) e2 t2 r_s3 rx"
    (* e2 will always be the generated variable *)
  apply (case_tac "e2 \<noteq> VarExp x SelfRef")
   apply (case_tac c)
                apply (auto)
    (* simple var reqs *)
   apply (simp add: add_env_def)
    apply (case_tac c)
               apply (auto)
   apply (simp add: deref_name_def)
  apply (simp add: add_env_def)
  apply (auto)
    apply (case_tac c)
                apply (auto)
    apply (simp add: pure_fun_def)
   apply (rule_tac ereq_leq_use_envx)
   apply (simp add: add_use_env_def)
    (* prelim: x2 is fresh *)
  apply (case_tac "\<not> fresh_var s1 x")
   apply (case_tac c)
                apply (auto)
    (* prelim: cs is empty, remove elim *)(*
  apply (case_tac "\<not> cs = {}")
   apply (case_tac c)
                apply (auto)*)
    (* prelim: r_s3 \<le> r_s1 *)
  apply (cut_tac r_sc="r_s3" and r_sb="diff_use_env r_s2 (comp_use_env rx1 (lift_use_env rx2 r))" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* we can achieve the desired permissions by removing x from the end perms + reqs (which is okay since they dont appear anywhere else yet). *)
  apply (rule_tac x="one_use_env x OwnPerm" in exI)
  apply (auto)
    (* - the end perm bound is possible since we assume r_s3 didnt already contain x2 *)
    apply (rule_tac t=" leq_use_env r_s3 (diff_use_env (add_use_env r_s1 x OwnPerm) (comp_use_env (ereq_use_env x t2) (one_use_env x OwnPerm)))" and
        s=" leq_use_env (rem_use_env r_s3 x) (diff_use_env (add_use_env r_s1 x OwnPerm) (comp_use_env (ereq_use_env x t2) (one_use_env x OwnPerm)))" in subst)
     apply (cut_tac r_s="r_s3" and x="x" in ignore_rem_use_env)
      apply (rule_tac r_s="r_s1" in leq_use_none)
       apply (auto)
     apply (simp add: valid_exp_use_env_def)
     apply (simp add: sub_use_env_def)
     apply (auto)
     apply (erule_tac x="x" in allE)
     apply (simp add: fresh_var_def)
     apply (cut_tac r_x="r_s1" and r_s="r_f" and x="x" in leq_use_none)
       apply (auto)
    (* - given this, we can finish proving the bound *)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac rhs_unroll_rem_use_env)
    apply (rule_tac dist_rem_leq_use_env)
    apply (rule_tac rhs_weak_leq_use_env)
     apply (rule_tac weak_ereq_use_env)
     apply (case_tac c)
                   apply (auto)
     apply (simp add: pure_fun_def)
     apply (simp add: unlim_def)
    apply (rule_tac rhs_add_leq_use_env)
     apply (auto)
    (* - unrolling definitions to prove the subtracter bound *)
   apply (simp add: leq_use_env_def)
   apply (simp add: one_use_env_def)
   apply (simp add: add_use_env_def)
    (* - proving the requirement bound *)
  apply (rule_tac r_sb="diff_use_env (ereq_use_env x t2) (one_use_env x OwnPerm)" in trans_leq_use_env)
   apply (simp add: ereq_use_env_def)
   apply (rule_tac diff_one_leq_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac self_diff_leq_use_env)
  done    
    
lemma add_env_force_ex: "\<lbrakk> \<forall> z. add_env s x v z = add_env s x w z \<rbrakk> \<Longrightarrow> v = w"    
  apply (erule_tac x="x" in allE)
  apply (simp add: add_env_def)
  done
    
lemma add_env_force: "\<lbrakk> add_env s x v = add_env s x w \<rbrakk> \<Longrightarrow> v = w"    
  apply (rule_tac s="s" and x="x" and v="v" and w="w" in add_env_force_ex)
  apply (auto)
  done
    
lemma disj_add_use_env: "\<lbrakk> disj_use_env r_s r_x; r_s x = NoPerm \<rbrakk> \<Longrightarrow> disj_use_env r_s (add_use_env r_x x r)"    
  apply (simp add: disj_use_env_def)
  apply (simp add: add_use_env_def)
  apply (simp add: mini_disj_use_env_def)
  done
    
lemma strong_disj_add_use_env: "\<lbrakk> strong_disj_use_env r_s r_x; r_s x = NoPerm \<rbrakk> \<Longrightarrow> strong_disj_use_env r_s (add_use_env r_x x r)"    
  apply (simp add: strong_disj_use_env_def)
  apply (simp add: add_use_env_def)
  done    

lemma add_valid_exp_use_env: "\<lbrakk> valid_nres_map s rs_map; valid_exp_use_env s rs_map r_s; fresh_var s x \<rbrakk> \<Longrightarrow>
  valid_exp_use_env (add_env s x v) (add_env rs_map x empty_use_env) (add_use_env r_s x OwnPerm)"  
  apply (simp add: valid_exp_use_env_def)  
  apply (auto)
    (* domain preservation *)
   apply (rule_tac rhs_add_sub_use_env)
   apply (rule_tac add_sub_use_env)
    apply (simp)
   apply (simp add: add_env_def)
    (* separation *)
  apply (simp add: sep_nres_map_def)
  apply (auto)
  apply (case_tac "x = xa")
   apply (auto)
   apply (simp add: nres_add_same)
   apply (rule_tac empty_strong_disj_use_env2)
  apply (simp add: nres_add_diff)
  apply (erule_tac x="xa" in allE)
  apply (rule_tac comm_strong_disj_use_env)
  apply (rule_tac strong_disj_add_use_env)
  apply (rule_tac comm_strong_disj_use_env)
   apply (simp)
  apply (simp add: valid_nres_map_def)
  apply (simp add: sub_nres_map_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (simp add: sub_use_env_def)
  apply (simp add: fresh_var_def)
  done
    
    
lemma add_valid_use_env: "\<lbrakk> valid_res_map s rs_map; valid_use_env s rs_map r_c r_s; fresh_var s x \<rbrakk> \<Longrightarrow>
  valid_use_env (add_env s x v) (add_mem rs_map x empty_use_env) (add_use_env r_c x OwnPerm) (add_use_env r_s x OwnPerm)"    
  apply (simp add: valid_use_env_def)
  apply (auto)
    (* subset preservation *)
      apply (rule_tac rhs_add_sub_use_env)
       apply (rule_tac add_sub_use_env)
       apply (simp)
      apply (simp add: add_env_def)
    (* main perm set containment *)
     apply (rule_tac dist_add_leq_use_env)
     apply (simp)
    (* resource perm set containment *)
  apply (simp add: valid_use_entry_def)
  apply (auto)
   apply (case_tac "x = xa")
    apply (cut_tac rs_map="rs_map" and x="x" and r_s="empty_use_env" in lookup_add_mem_same)
    apply (auto)
    apply (rule_tac leq_empty_use_env)
   apply (cut_tac rs_map="rs_map" and x="x" and y="xa" and r_s="empty_use_env" in lookup_add_mem_diff)
    apply (auto)
   apply (erule_tac x="xa" in allE)
   apply (auto)
    apply (simp add: add_use_env_def)
   apply (rule_tac rhs_add_leq_use_env)
    apply (auto)
    (* resource perm set disjointness *)
  apply (case_tac "x = xa")
   apply (cut_tac rs_map="rs_map" and x="x" and r_s="empty_use_env" in lookup_add_mem_same)
   apply (auto)
   apply (rule_tac empty_strong_disj_use_env1)
  apply (cut_tac rs_map="rs_map" and x="x" and y="xa" and r_s="empty_use_env" in lookup_add_mem_diff)
   apply (auto)
  apply (rule_tac strong_disj_add_use_env)
   apply (erule_tac x="xa" in allE)
   apply (simp add: add_use_env_def)
  apply (simp add: valid_res_map_def)
    (* - by scoping, x cannot be in rs_map xa unless it is in rs_map, meaning it is in s, a contradiction *)
  apply (cut_tac rs_map="rs_map" and x="xa" in self_scope_use_env)
   apply (simp)
  apply (case_tac "lookup_mem rs_map x = None")
   apply (simp add: scope_use_env_def)
  apply (simp add: sub_res_map_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (simp add: fresh_var_def)
    (* - proving the weak part of rs_map is still contained *)(*
  apply (case_tac "x = xa")
   apply (cut_tac rs_map="rs_map" and r_s="empty_use_env" and x="xa" in lookup_add_mem_same)
   apply (auto)
   apply (rule_tac sdrop_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (erule_tac x="xa" in allE)
  apply (auto)
   apply (simp add: add_use_env_def)
  apply (cut_tac rs_map="rs_map" and r_s="empty_use_env" and x="x" and y="xa" in lookup_add_mem_diff)
   apply (auto)
  apply (rule_tac rhs_add_leq_use_env)
   apply (simp_all)*)
  done
    


  
    (*
      the hard part that we're dealing with right now is that at the end using pairs does NOT work for the WRITE constants,
        since we want "use" permission for the array, but "own" permission for the value being written.

      what this suggests is that we have to allow for constant + application to be a value.
      even if we do this, we need to give them all their own unique cases, just like for unpacking.
      - this is more complicated than it is with constants, since the contents of the first arg will generally be somewhat complex.

    *)
    
    (*
lemma sacc_use_case: "\<lbrakk>well_typed_state s1 env rs_map; valid_exp_use_env s1 rs_map r_f; well_typed env r_s1 v t1 r_s2 rx2;
           leq_use_env r_s3 (diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)); leq_use_env rx r_s3; leq_use_env r_s1 r_f;
           leq_use_env (app_req rx1 rx2 r t2 r_ex) rx; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s2; leq_use_env r_ex r_s1;
           FunTy t1 t2 r a \<in> const_type c; c \<noteq> FixConst; ax = UseAct x3; is_value v; app_con s1 c v (UseAct x3) (s2, e2)\<rbrakk>
          \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (exp_red_use_env r_s1 g_ax) e2 t2 r_s3 rx \<and>
                     well_typed_state s2 (red_env env g_ax) (red_nres_map rs_map g_ax) \<and>
                     valid_exp_use_env s2 (red_nres_map rs_map g_ax) (exp_red_use_env r_f g_ax) \<and>
                     safe_act s1 r_f g_ax \<and> corr_act (UseAct x3) g_ax"    
    (* array ext case *)
  apply (case_tac c)
              apply (auto)
    apply (rule_tac x="WriteResAct x3" in exI)
    (* array read case *)
    (* - first we have to extract the type of e2. *)
  apply (cut_tac rs_map="rs_map" and s="s1" and env="env" and i="i" and v="va" and x="deref_name x3 aa" and arr="arr" in well_typed_lookup_array_elem)
      apply (auto)
   apply (simp add: pure_fun_def)
  apply (rule_tac x="ReadResAct" in exI)
  apply (auto)
    (* - the idea here is that e2 should be re-typed so that all of its permissions are encompassed by x3. *)
  apply (cut_tac env="env" and s="s1" and rs_map="rs_map" in wts_mem_val_env)
   apply (auto)
  apply (case_tac "\<not> mem_ty tau_x")
   apply (simp add: mem_val_env_def)
   apply (erule_tac x="x3" in allE)
   apply (auto)
  apply (case_tac tau_x)
        apply (auto)
  apply (cut_tac env="env" and r_x="r_x" and e="va" and tau="t" and t="x4" and x="x3" and r_s="one_use_env x3 UsePerm" in well_typed_ack_exp)
          apply (auto)
   apply (simp add: one_use_env_def)
  apply (simp add: mem_val_env_def)
  apply (erule_tac x="x3" in allE)
  apply (auto)
    (* prelim: r_s3 \<le> r_s1 *)
  apply (cut_tac r_sc="r_s2" and r_sb="diff_use_env r_s3a r_exaa" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 (comp_use_env (ereq_use_env x3 (ArrayTy x4)) r_exa)" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (auto)
  apply (cut_tac r_sc="r_s3" and r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (auto)
    (* analysis based on whether x3 is in rx or not *)
  apply (case_tac "rx x3 \<noteq> NoPerm")
   apply (case_tac "\<not> leq_use_env (one_use_env x3 UsePerm) rx")
    apply (simp add: leq_use_env_def)
    apply (simp add: one_use_env_def)
    apply (auto)
    apply (case_tac "x3 = x")
     apply (auto)
    apply (case_tac "rx x3")
      apply (auto)
   apply (rule_tac ?r_s1.0="r_s3" in well_typed_incr_start_perm)
    apply (rule_tac rx="one_use_env x3 UsePerm" in well_typed_incr_req)
      apply (rule_tac r_s="one_use_env x3 UsePerm" in well_typed_incr_simul_perm)
       apply (rule_tac r_sb="rx" in trans_leq_use_env)
        apply (auto)
   apply (simp add: pure_fun_def)
    (* prelim: x3 \<le> r_s1 *)
  apply (cut_tac r_sc="one_use_env x3 UsePerm" and r_sb="ereq_use_env x3 (ArrayTy x4)" and r_sa="r_s1" in trans_leq_use_env)
    apply (simp)
   apply (simp add: ereq_use_env_def)
   apply (simp add: leq_use_env_def)
   apply (simp add: one_use_env_def)
   apply (simp add: end_req_perm_def)
    (* case where t2 = Prim *)
  apply (simp add: app_req_def)
  apply (case_tac "req_type t2 = Prim")
   apply (auto)
   apply (rule_tac ?r_s2.0="r_s1" and rx="empty_use_env" in well_typed_simul_end_perm)
      apply (rule_tac rx="one_use_env x3 UsePerm" in wt_sexp_no_req)
        apply (rule_tac r_s="one_use_env x3 UsePerm" in well_typed_incr_simul_perm)
         apply (auto)
    apply (simp add: pure_fun_def)
   apply (rule_tac value_is_sexp)
   apply (rule_tac ?e1.0="va" in ack_full_exp_value)
    apply (auto)
    (* otherwise, since rx x3 = NoPerm, we prepare a diff *)
  apply (rule_tac ?r_s2.0="diff_use_env r_s1 (comp_use_env (comp_use_env (comp_use_env (ereq_use_env x3 (ArrayTy x4)) r_exa) r_exaa)
          (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" and
      rx="diff_use_env (one_use_env x3 UsePerm) (comp_use_env (comp_use_env (comp_use_env (ereq_use_env x3 (ArrayTy x4)) r_exa) r_exaa)
          (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac r_s="one_use_env x3 UsePerm" in well_typed_incr_simul_perm)
       apply (simp)
      apply (simp add: pure_fun_def)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
      apply (auto)
   apply (rule_tac r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s3a r_exaa" in trans_leq_use_env)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
      apply (auto)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (simp add: pair_req_def)
  apply (simp add: pure_fun_def)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1a rx2a) r_exaa" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env1)
  apply (auto)
  apply (rule_tac r_sb="diff_use_env (ereq_use_env x3 (ArrayTy x4)) (comp_use_env (ereq_use_env x3 (ArrayTy x4)) r_exa)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac dist_diff_leq_use_env)
  apply (simp add: ereq_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (simp add: one_use_env_def)
  apply (simp add: end_req_perm_def)
  done*)
    
lemma saccmk2_var_type: "\<lbrakk> env x = Some (ChanTy t c_end) \<rbrakk> \<Longrightarrow>
  well_typed env (one_use_env x OwnPerm) (VarExp x SelfRef) (ChanTy t c_end) (one_use_env x OwnPerm) (one_use_env x OwnPerm)"    
  apply (auto)
    apply (simp add: deref_name_def)
   apply (rule_tac ereq_leq_use_envx)
   apply (simp add: one_use_env_def)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
     apply (rule_tac rhs_weak_leq_use_env)
      apply (rule_tac dist_weak_comp_use_env)
       apply (rule_tac weak_ereq_use_env)
       apply (simp add: unlim_def)
      apply (simp add: weak_use_env_def)
      apply (simp add: empty_use_env_def)
     apply (rule_tac id_leq_use_env)
     apply (rule_tac id_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac diff_leq_use_env)
  apply (rule_tac ereq_leq_use_envx)
  apply (simp add: one_use_env_def)
  done
  
lemma saccmk2_pair_type: "\<lbrakk> well_typed env (one_use_env x1 OwnPerm) v1 t1 (one_use_env x1 OwnPerm) (one_use_env x1 OwnPerm);
  well_typed env (one_use_env x2 OwnPerm) v2 t2 (one_use_env x2 OwnPerm) (one_use_env x2 OwnPerm);
  r_s1 x1 = OwnPerm; r_s1 x2 = OwnPerm; r_s2 x1 = NoPerm; r_s2 x2 = NoPerm;
  leq_use_env r_s2 r_s1; leq_use_env rx r_s2; is_own r; x1 \<noteq> x2 \<rbrakk> \<Longrightarrow>
  well_typed env r_s1 (PairExp v1 v2) (PairTy t1 t2 r) r_s2 rx"
  apply (auto)
  apply (rule_tac x="r_s1" in exI)
  apply (rule_tac x="r_s1" in exI)
  apply (rule_tac x="one_use_env x1 OwnPerm" in exI)
  apply (auto)
   apply (rule_tac r_s="one_use_env x1 OwnPerm" in well_typed_incr_simul_perm)
    apply (simp add: leq_use_env_def)
    apply (simp add: one_use_env_def)
   apply (simp)
  apply (rule_tac x="one_use_env x2 OwnPerm" in exI)
  apply (auto)
         apply (rule_tac r_s="one_use_env x2 OwnPerm" in well_typed_incr_simul_perm)
            apply (simp add: leq_use_env_def)
            apply (simp add: one_use_env_def)
           apply (simp)
          apply (simp add: is_own_def)
         apply (simp add: leq_use_env_def)
         apply (simp add: one_use_env_def)
         apply (simp add: is_own_def)
        apply (simp add: leq_use_env_def)
        apply (simp add: one_use_env_def)
        apply (simp add: is_own_def)
       apply (simp add: is_own_def)
      apply (simp add: is_own_def)
     apply (simp add: is_own_def)
    apply (simp add: is_own_def)
   apply (simp add: is_own_def)
   apply (simp add: one_use_env_def)
   apply (simp add: disj_use_env_def)
   apply (simp add: mini_disj_use_env_def)
  apply (rule_tac x="add_use_env (one_use_env x1 OwnPerm) x2 OwnPerm" in exI)
  apply (auto)
    apply (rule_tac mini_disj_diff_leq_use_env2)
     apply (simp)
    apply (simp add: mini_disj_use_env_def)
    apply (simp add: one_use_env_def)
    apply (simp add: add_use_env_def)
    apply (auto)
   apply (rule_tac add_leq_use_env)
    apply (simp add: leq_use_env_def)
    apply (simp add: one_use_env_def)
   apply (auto)
  apply (simp add: pair_req_def)
  apply (auto)
    apply (simp add: leq_use_env_def)
    apply (simp add: add_use_env_def)
    apply (simp add: diff_use_env_def)
    apply (simp add: comp_use_env_def)
    apply (simp add: minus_use_env_def)
    apply (simp add: neg_use_env_def)
    apply (simp add: one_use_env_def)
   apply (simp add: is_own_def)
  apply (simp add: is_own_def)
  done
    
lemma sacc_mk2_act_case: "
  \<lbrakk>well_typed_state s1 env rs_map; valid_exp_use_env s1 rs_map r_f; well_typed env r_s1 v t1 r_s2 rx2; proper_exp rs_map (AppExp (ConstExp c) v);
                leq_use_env r_s3 (diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex));
                leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s2; leq_use_env r_ex r_s1; leq_use_env rx r_s3;
                leq_use_env (app_req rx1 rx2 r t2 r_ex) rx; leq_use_env r_s1 r_f; FunTy t1 t2 r a \<in> const_type c; c \<noteq> FixConst; ax = Mk2Act x31 x32;
                is_value v; app_con s1 c v (Mk2Act x31 x32) (s2, e2)\<rbrakk>
               \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (exp_red_use_env r_s1 g_ax) e2 t2 (end_red_use_env r_s3 g_ax) (end_red_use_env rx g_ax) \<and>
                          proper_exp (red_nres_map rs_map g_ax) e2 \<and>
                          well_typed_state s2 (red_env env g_ax) (red_nres_map rs_map g_ax) \<and>
                          valid_exp_use_env s2 (red_nres_map rs_map g_ax) (exp_red_use_env r_f g_ax) \<and>
                          safe_act s1 (infl_use_env r_f r_s3) g_ax \<and> corr_act (Mk2Act x31 x32) g_ax"
  apply (case_tac c)
              apply (auto)
  apply (cut_tac eq_own)
  apply (auto)
  apply (rule_tac x="Add2ResAct x31 x32 t" in exI)
  apply (auto)
       apply (cut_tac env="add_env (add_env env x31 (ChanTy t SEnd)) x32 (ChanTy t REnd)" and
        ?r_s1.0="add_use_env (add_use_env r_s1 x31 OwnPerm) x32 OwnPerm" and
        ?r_s2.0="r_s3" and ?v1.0="VarExp x31 SelfRef" and ?v2.0="VarExp x32 SelfRef" and ?t1.0="ChanTy t SEnd" and ?t2.0="ChanTy t REnd"
        and ?x1.0="x31" and ?x2.0="x32" in saccmk2_pair_type)
                 apply (rule_tac saccmk2_var_type)
                 apply (simp add: add_env_def)
                apply (rule_tac saccmk2_var_type)
                apply (simp add: add_env_def)
               apply (auto)
            apply (simp add: add_use_env_def)
           apply (simp add: add_use_env_def)
          apply (rule_tac r_s="r_f" in leq_use_none)
           apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
            apply (simp)
           apply (rule_tac r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
            apply (rule_tac diff_leq_use_env)
            apply (simp_all)
          apply (simp add: fresh_var_def)
          apply (simp add: valid_exp_use_env_def)
          apply (simp add: sub_use_env_def)
         apply (rule_tac r_s="r_f" in leq_use_none)
          apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
           apply (simp)
          apply (rule_tac r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
           apply (rule_tac diff_leq_use_env)
           apply (simp_all)
         apply (simp add: fresh_var_def)
         apply (simp add: valid_exp_use_env_def)
         apply (simp add: sub_use_env_def)
        apply (rule_tac rhs_add_leq_use_env)
         apply (rule_tac rhs_add_leq_use_env)
          apply (rule_tac r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
           apply (rule_tac diff_leq_use_env)
           apply (simp_all)
       apply (rule_tac x="ChanTy t REnd" in exI)
       apply (rule_tac x="ra" in exI)
       apply (auto)
        apply (simp add: pure_fun_def)
        apply (simp add: is_own_def)
       apply (rule_tac x="r_s2a" in exI)
       apply (rule_tac x="r_s3a" in exI)
       apply (rule_tac x="rx1a" in exI)
       apply (auto)
       apply (rule_tac x="rx2a" in exI)
       apply (auto)
       apply (rule_tac x="r_exb" in exI)
       apply (auto)
       apply (simp add: pure_fun_def)
       apply (simp add: is_own_def)
    (* proving the state remains proper *)
      apply (simp add: proper_exp_def)
    (* proving the state remains well-typed: environment containment *)
     apply (simp add: well_typed_state_def)
     apply (auto)
       apply (rule_tac dist_add_sub_env)
       apply (rule_tac dist_add_sub_env)
       apply (simp)
    (* res_map validity: completeness *)
      apply (simp add: valid_nres_map_def)
      apply (auto)
        apply (rule_tac add_full_nres_map)
        apply (rule_tac add_full_nres_map)
        apply (simp)
    (* - disjointness *)
       apply (rule_tac disj_add_nres_map)
        apply (rule_tac disj_add_nres_map)
         apply (simp)
        apply (simp add: sep_nres_map_def)
        apply (simp add: empty_strong_disj_use_env1)
       apply (simp add: sep_nres_map_def)
       apply (simp add: empty_strong_disj_use_env1)
    (* - element containment *)
      apply (rule_tac dist_add_sub_nres_map)
       apply (rule_tac dist_add_sub_nres_map)
        apply (simp)
       apply (rule_tac empty_sub_use_env)
      apply (rule_tac empty_sub_use_env)
    (* proving that the memory is still well-typed. starting with x = x31 / x = x32 *)
     apply (case_tac "x = x31")
      apply (simp add: add_env_def)
     apply (case_tac "x = x32")
      apply (simp add: add_env_def)
    (* - otherwise compare with the originals *)
     apply (simp add: add_env_def)
     apply (erule_tac x="x" in allE)
     apply (case_tac "s1 x")
      apply (auto)
     apply (simp add: add_env_def)
     apply (case_tac "env x")
      apply (auto)
     apply (rule_tac well_typed_mv_add_vars)
      apply (rule_tac well_typed_mv_add_vars)
       apply (simp add: nres_lookup_def)
       apply (simp add: add_env_def)
      apply (simp add: fresh_var_def)
      apply (simp add: sub_env_def)
     apply (simp add: fresh_var_def)
     apply (simp add: sub_env_def)
      apply (simp add: add_env_def)
    (* - properness *)
     apply (rule_tac proper_add_mv)
      apply (rule_tac proper_add_mv)
       apply (simp)
      apply (simp add: fresh_var_def)
      apply (simp add: valid_nres_map_def)
      apply (simp add: full_nres_map_def)
      apply (simp add: nres_lookup_def)
      apply (rule_tac leq_empty_use_env)
     apply (simp add: fresh_var_def)
     apply (simp add: valid_nres_map_def)
     apply (simp add: full_nres_map_def)
     apply (simp add: nres_lookup_def)
     apply (simp add: add_env_def)
     apply (rule_tac leq_empty_use_env)
    (* proving the new res_map is still valid: expression map containment *)
    apply (simp add: valid_exp_use_env_def)
    apply (auto)
     apply (rule_tac rhs_add_sub_use_env)
      apply (rule_tac rhs_add_sub_use_env)
       apply (rule_tac add_sub_use_env)
       apply (rule_tac add_sub_use_env)
       apply (simp)
      apply (simp add: add_env_def)
     apply (simp add: add_env_def)
    (* map separation *)
    apply (rule_tac add_sep_nres_map)
     apply (rule_tac add_sep_nres_map)
      apply (simp add: sep_nres_map_def)
      apply (auto)
      apply (simp add: well_typed_state_def)
      apply (simp add: valid_nres_map_def)
      apply (simp add: sub_nres_map_def)
      apply (rule_tac add_strong_disj_use_env)
       apply (rule_tac add_strong_disj_use_env)
        apply (simp)
       apply (simp add: sub_use_env_def)
       apply (simp add: fresh_var_def)
      apply (simp add: sub_use_env_def)
      apply (simp add: fresh_var_def)
     apply (rule_tac empty_strong_disj_use_env2)
    apply (rule_tac empty_strong_disj_use_env2)
   apply (simp add: fresh_var_def)
  apply (simp add: fresh_var_def)
  done
      
  
    (* the idea is that if we added a permission, we required it to be a variable not already in the env, ie a variable free in e2.
      so then we can remove x by default. *)
    (* in general, this statement says that given a constant-application, the result can be typed with a certain env + perm set,
      so that the state remains well-typed relative to the env + global perm_map, and the env + perm set remains valid *)
lemma safe_app_con_case: "\<lbrakk> well_typed_state s1 env rs_map;
    app_red_exp ConstApp (s1, AppExp (ConstExp c) v) ax (s2, e2); valid_exp_use_env s1 rs_map r_f;
    well_typed env r_s1 v t1 r_s2 rx2; proper_exp rs_map (AppExp (ConstExp c) v);
    leq_use_env r_s3 (diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex));
    leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s2; leq_use_env r_ex r_s1;
    leq_use_env rx r_s3; leq_use_env (app_req rx1 rx2 r t2 r_ex) rx; leq_use_env r_s1 r_f;
    FunTy t1 t2 r a \<in> const_type c; c \<noteq> FixConst\<rbrakk>
       \<Longrightarrow> \<exists>g_ax . well_typed (red_env env g_ax) (exp_red_use_env r_s1 g_ax) e2 t2 (end_red_use_env r_s3 g_ax) (end_red_use_env rx g_ax) \<and>
                  proper_exp (red_nres_map rs_map g_ax) e2 \<and> well_typed_state s2 (red_env env g_ax) (red_nres_map rs_map g_ax) \<and>
                  valid_exp_use_env s2 (red_nres_map rs_map g_ax) (exp_red_use_env r_f g_ax) \<and> safe_act s1 (infl_use_env r_f r_s3) g_ax \<and> corr_act ax g_ax"
  apply (case_tac ax)
     apply (auto)
    (* no action cases *)
     apply (case_tac c)
                 apply (auto)
    (* new resource cases. in all cases t2 should be the correct type to add *)
    apply (rule_tac x="AddResAct x2 t2 empty_use_env" in exI)
    apply (auto)
    (* - lemma for main well-typedness statement *)
        apply (rule_tac ?s2.0="s2" and ?rx1.0="rx1" in sacc_make_act_case)
                  apply (auto)
         apply (rule_tac r_sb="diff_use_env r_s2 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
          apply (rule_tac lhs_unroll_dcl_use_env)
          apply (rule_tac self_diff_leq_use_env)
         apply (simp)
    (* - proper expression *)
        apply (case_tac c)
                    apply (auto)
        apply (simp add: proper_exp_def)
    (* - well typed state. *)
       apply (case_tac "\<not> (\<exists> v. s2 = add_env s1 x2 v)")
        apply (case_tac c)
                    apply (auto)
       apply (rule_tac well_typed_state_add_vars)
           apply (auto)
          apply (case_tac c)
                      apply (auto)
    (* - wt mem val: array case *)
         apply (case_tac c)
                     apply (auto)
         apply (cut_tac s="s1" and x="x2" and v="va" and w="ArrValue []" in add_env_force)
          apply (auto)
         apply (simp add: pure_fun_def)
    (* - valid res list *)
         apply (rule_tac x="\<lambda> x. None" in exI)
          apply (simp add: valid_res_list_def)
    (* - properness *)
         apply (case_tac c)
                     apply (auto)
         apply (cut_tac s="s1" and x="x2" and v="va" and w="ArrValue []" in add_env_force)
          apply (simp)
         apply (auto)
    (* - x22 is contained in rs_map (true because x22 is the empty set) *)
        apply (simp add: sub_use_env_def)
        apply (simp add: empty_use_env_def)
    (* - map separation + strength *)
       apply (simp add: sep_nres_map_def)
       apply (auto)
       apply (rule_tac empty_strong_disj_use_env1)
    (* - valid use env. *)
      apply (case_tac "\<not> (\<exists> v. s2 = add_env s1 x2 v)")
       apply (case_tac c)
                   apply (auto)
      apply (rule_tac add_valid_exp_use_env)
        apply (simp add: well_typed_state_def)
       apply (simp)
      apply (case_tac c)
                  apply (auto)
     apply (case_tac c)
                 apply (auto)
     apply (simp add: fresh_var_def)
    apply (rule_tac leq_empty_use_env)
    (* dual new resource case. (basically only channel creation) *)
   apply (rule_tac sacc_mk2_act_case)
                apply (auto)
    (* resource usage case. (currently empty) *)
  apply (case_tac c)
              apply (auto)
(*
   apply (case_tac c)
                apply (auto)
  apply (case_tac c)
               apply (auto)*)
  done    

  
lemma well_typed_empty_state: "well_typed_state empty_env empty_env empty_env"
  apply (simp add: well_typed_state_def)
  apply (auto)
    apply (simp add: sub_env_def)
    apply (simp add: empty_env_def)
   apply (simp add: valid_nres_map_def)(*
   apply (simp add: disj_res_map_def)
   apply (auto)
     apply (simp add: lookup_res_def)
     apply (rule_tac empty_strong_disj_use_env1)*)
   apply (auto)
     apply (simp add: full_nres_map_def)
     apply (simp add: empty_env_def)
    apply (simp add: disj_nres_map_def)
    apply (auto)
    apply (simp add: nres_lookup_def)
    apply (simp add: empty_env_def)
    apply (rule_tac empty_strong_disj_use_env1)
   apply (simp add: sub_nres_map_def)
   apply (simp add: sub_use_env_def)
   apply (simp add: nres_lookup_def)
   apply (simp add: empty_env_def)
   apply (simp add: empty_use_env_def) 
  apply (simp add: empty_env_def)
  done
  (*
lemma well_typed_empty_env: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; well_typed_state s env rs_map; non_prim_env env; leq_use_env r_s1 empty_use_env \<rbrakk> \<Longrightarrow>
  well_typed empty_env r_s1 e tau r_s2 rx"
  apply (cut_tac env="env" and rs_map="empty_env" and v="e" and ?r_s1.0="r_s1" and s="s" in well_typed_restr)
     apply (simp add: well_typed_state_def)
     apply (simp add: valid_nres_map_def)
    
     apply (simp add: scope_res_map_def)
    apply (simp add: scope_use_env_def)
    apply (simp add: leq_use_env_def)
    apply (simp add: empty_use_env_def)
    apply (auto)
   apply (erule_tac x="x" in allE)
   apply (case_tac "r_s1 x")
     apply (auto)
  apply (rule_tac s="restr_env env NilStack" and t="empty_env" in subst)
   apply (case_tac "\<not> (\<forall> x. restr_env env NilStack x = empty_env x)")
    apply (auto)
  apply (simp add: restr_env_def)
  apply (simp add: empty_env_def)
  done*)
  
fun state_vars where
  "state_vars s = { x | x. s x \<noteq> None }"
  
definition fv_restr_env where
  "fv_restr_env e s = (\<lambda> x. if x \<in> free_vars e then s x else None)"
  
lemma fv_restr_env_use: "\<lbrakk> x \<in> free_vars e \<rbrakk> \<Longrightarrow> fv_restr_env e s x = s x"  
  apply (simp add: fv_restr_env_def)
  done
    
lemma dist_rem_contain_env: "\<lbrakk> contain_env s s' \<rbrakk> \<Longrightarrow> contain_env (rem_env s x) (rem_env s' x)"    
  apply (simp add: contain_env_def)
  apply (simp add: rem_env_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (case_tac "s' xa")
   apply (auto)
  apply (simp add: rem_env_def)
  done

lemma fv_contain_env: "\<lbrakk> free_vars e' \<subseteq> free_vars e \<rbrakk> \<Longrightarrow> contain_env (fv_restr_env e s) (fv_restr_env e' s)"    
  apply (simp add: contain_env_def)
  apply (simp add: fv_restr_env_def)
  apply (auto)
  apply (case_tac "s x")
   apply (auto)
  apply (simp add: fv_restr_env_def)
  apply (auto)
  done

lemma rem_fv_contain_env: "\<lbrakk> free_vars e' - {x} \<subseteq> free_vars e \<rbrakk> \<Longrightarrow> contain_env (fv_restr_env e (rem_env s x)) (fv_restr_env e' (rem_env s x))"    
  apply (simp add: contain_env_def)
  apply (simp add: fv_restr_env_def)
  apply (auto)
  apply (simp add: rem_env_def)
  apply (auto)
  apply (case_tac "s xa")
   apply (auto)
  apply (simp add: fv_restr_env_def)
  apply (simp add: rem_env_def)
  apply (auto)
  done
    
lemma rem_fv_restr_env: "rem_env (fv_restr_env e s) x = fv_restr_env e (rem_env s x)"    
  apply (case_tac "\<not> (\<forall> y. rem_env (fv_restr_env e s) x y = fv_restr_env e (rem_env s x) y)")
   apply (auto)
  apply (simp add: rem_env_def)
  apply (simp add: fv_restr_env_def)
  apply (case_tac "x = y")
   apply (auto)
   apply (case_tac "x \<in> free_vars e")
    apply (auto)
  apply (simp add: fv_restr_env_def)
  apply (case_tac "y \<in> free_vars e")
   apply (auto)
  done
(*
lemma fv_restr_contain_env: "\<lbrakk> scope_use_env rs_map r_s; non_prim_env env; well_typed env r_s v tau r_se r_xe \<rbrakk> \<Longrightarrow>
  contain_env (restr_env s rs_map) (fv_restr_env v s)"    
  apply (simp add: contain_env_def)
  apply (simp add: fv_restr_env_def)
  apply (auto)
  apply (case_tac "s x")
   apply (auto)
  apply (simp add: scope_use_env_def)
  apply (erule_tac x="x" in allE)
  apply (auto)
   apply (simp add: restr_env_def)
  apply (cut_tac x="x" and e="v" and ?r_s1.0="r_s" in well_typed_no_npv_use)
    apply (auto)
  apply (simp add: non_prim_vars_def)
  apply (simp add: non_prim_env_def)
  apply (erule_tac x="x" in allE)
  apply (cut_tac env="env" and x="x" and e="v" in well_typed_fv_env_use)
    apply (auto)
  apply (simp add: non_prim_entry_def)
  done*)
  
    
    (* the question is, how do we allow for replicable pairs while enforcing full resource disjointness?
        i guess the "natural" way to do it based on what we already have is to simply allow pairs that contain
        values that are not unique to also be values.

        - if x is in the end perms, x is in the reqs. if r is own, (lift rx r) subtracts it out.
        - if r is not own, it means that e is replicable, in which case it is again not a var,
        - x is not in the end perms, which is trivial

        an even cleaner solution is to make a "replicable" pair value and type accordingly.
        in this case e is still a var, however at the level of reduction semantics, we can keep
        the var out of the name set.
     *)
    
    (* this lemma is used to show that variables passed into pair constructors are semi-disjoint.
        we do this by showing that the var is not in the end perms after the reqs are removed.
        - if x is in the end perms, x is in the reqs. if r is own, (lift rx r) subtracts it out.
        - if r is not own, e is non-affine, meaning the "var" is not passed in. (empty name set)
        - if x is not in the end perms, trivial.
     *)
    
definition is_var where
  "is_var e x = (if e = VarExp x NoRef then False else True)"
    
fun size_mem :: "'a p_stack \<Rightarrow> nat" where  
  "size_mem NilStack = 0"
| "size_mem (ConsStack x v s') = (size_mem s' + 1)"
 
lemma decr_size_mem: "\<lbrakk> lookup_mem rs_map x = Some (r_s, rs_map') \<rbrakk> \<Longrightarrow> size_mem rs_map' < size_mem rs_map"    
  apply (induct rs_map)
   apply (auto)
  apply (case_tac "x1 = x")
   apply (auto)
  done
    
    
end