theory SPComp
  imports DropEnv NormEnv WTLemma
begin
    
    (* 
      ####################################
        P1. specialized definitions for the statement of stp
      ####################################
    *)
    
    (* - requirement negation (removes r_x only if it was already removed from r_se) *)
  
definition end_neg_use_env where
  "end_neg_use_env r_se x r_x r = (if r_se x = NoPerm then lift_use_env r_x r else empty_use_env)"

lemma end_neg_leq_use_env: "\<lbrakk> leq_use_env (lift_use_env r_x r) r_s \<rbrakk> \<Longrightarrow> leq_use_env (end_neg_use_env r_se x r_x r) r_s"  
  apply (simp add: end_neg_use_env_def)
  apply (auto)
  apply (rule_tac leq_empty_use_env)
  done

lemma dist_end_neg_leq_use_env: "\<lbrakk> leq_use_env r_sb r_sa \<rbrakk> \<Longrightarrow> leq_use_env (end_neg_use_env r_sa x r_x r) (end_neg_use_env r_sb x r_x r)"
  apply (simp add: end_neg_use_env_def)
  apply (auto)
     apply (rule_tac id_leq_use_env)
    apply (simp add: leq_use_env_def)
    apply (auto)
    apply (erule_tac x="x" in allE)
    apply (auto)
    apply (case_tac "r_sb x")
      apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac leq_empty_use_env)
  done
    
    (* - stpx requirements (defines the requirements taken from rx2 based on the requirements originally used) *)
    
definition stpx_req where
  "stpx_req rx1 rx2 r = (if r = NoPerm then rx1 else if r = UsePerm then comp_use_env rx1 (drop_use_env rx2) else comp_use_env rx1 rx2)"    
  
definition stpx_ex where
  "stpx_ex rx r = (if r = UsePerm then drop_use_env rx else if r = NoPerm then empty_use_env else rx)"  
  
definition stpx_compact where
  "stpx_compact rx1 rx2 r = (if r = NoPerm then rx1 else comp_use_env rx1 (stpx_ex rx2 r))"  
  
lemma stpx_compact_conv: "stpx_req rx1 rx2 r = stpx_compact rx1 rx2 r"
  apply (case_tac "\<forall> x. stpx_req rx1 rx2 r x = stpx_compact rx1 rx2 r x")
   apply (auto)
  apply (simp add: stpx_req_def)
  apply (simp add: stpx_compact_def)
  apply (simp add: stpx_ex_def)
  done
  
lemma stpx_req_leq_use_env: "\<lbrakk> leq_use_env (comp_use_env r_xa r_xb) r_s \<rbrakk>\<Longrightarrow> leq_use_env (stpx_req r_xa r_xb x) r_s"    
  apply (rule_tac r_sb="comp_use_env r_xa r_xb" in trans_leq_use_env)
   apply (simp)
  apply (simp add: stpx_req_def)
  apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac self_drop_leq_use_env)
   apply (rule_tac self_comp_leq_use_env1)
  apply (rule_tac id_leq_use_env)
  done
  
lemma stpx_req_leq_use_env2: "\<lbrakk> leq_use_env r_x r_sa \<rbrakk>\<Longrightarrow> leq_use_env r_x (stpx_req r_sa r_sb x)"    
  apply (simp add: stpx_req_def)
  apply (auto)
  apply (rule_tac r_sb="r_sa" in trans_leq_use_env)
    apply (rule_tac self_comp_leq_use_env1)
   apply (simp)
  apply (rule_tac comp_leq_use_env1)
  apply (simp)
  done

    
lemma stpx_req_leq_use_env3: "\<lbrakk> leq_use_env (comp_use_env r_xa (stpx_ex r_xb r)) r_s \<rbrakk> \<Longrightarrow> leq_use_env (stpx_req r_xa r_xb r) r_s"
  apply (simp add: stpx_req_def)
  apply (auto)
    apply (simp add: stpx_ex_def)
   apply (rule_tac r_sb="comp_use_env r_xa (stpx_ex r_xb NoPerm)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac self_comp_leq_use_env1)
  apply (rule_tac r_sb="comp_use_env r_xa (stpx_ex r_xb r)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac self_comp_leq_use_env1)
  apply (simp add: stpx_ex_def)
  apply (rule_tac self_comp_leq_use_env2)
  done
  
lemma stpx_ex_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (stpx_ex r_x r) r_s"    
  apply (simp add: stpx_ex_def)
  apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac drop_leq_use_env)
  apply (simp)
  done
  
lemma dist_stpx_ex_leq_use_env: "\<lbrakk> leq_perm q r \<rbrakk> \<Longrightarrow> leq_use_env (stpx_ex (lift_use_env r_s q) q) (stpx_ex (lift_use_env r_s r) r)"    
  apply (case_tac q)
    apply (case_tac "stpx_ex (lift_use_env r_s q) q \<noteq> empty_use_env")
     apply (simp add: stpx_ex_def)
    apply (simp)
    apply (rule_tac leq_empty_use_env)
   apply (simp add: stpx_ex_def)
   apply (auto)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac drop_leq_use_env)
   apply (rule_tac self_lift_leq_use_env)
  apply (case_tac r)
    apply (auto)
  apply (rule_tac id_leq_use_env)
  done
  
lemma dist_stpx_ex_leq_use_env2: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (stpx_ex r_x r) (stpx_ex r_s r)"     
  apply (simp add: stpx_ex_def)
  apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac dist_drop_leq_use_env)
  apply (simp)
  done

lemma stpx_ex_disj_use_env: "\<lbrakk> disj_use_env r_xa r_xb \<rbrakk> \<Longrightarrow> disj_use_env (stpx_ex r_x (r_xa x)) (stpx_ex r_s (r_xb x))"
  apply (case_tac "r_xa x = OwnPerm")
   apply (case_tac "r_xb x \<noteq> NoPerm")
    apply (simp add: disj_use_env_def)
    apply (simp add: mini_disj_use_env_def)
   apply (simp add: stpx_ex_def)
   apply (rule_tac disj_empty_use_env1)
  apply (case_tac "r_xb x = OwnPerm")
   apply (case_tac "r_xa x \<noteq> NoPerm")
    apply (simp add: disj_use_env_def)
    apply (simp add: mini_disj_use_env_def)
   apply (simp add: stpx_ex_def)
   apply (rule_tac disj_empty_use_env2)
  apply (case_tac "\<not> weak_use_env empty_use_env")
   apply (simp add: weak_use_env_def)
   apply (simp add: empty_use_env_def)
  apply (rule_tac double_weak_disj_use_env)
   apply (simp add: stpx_ex_def)
   apply (auto)
    apply (rule_tac drop_weak_use_env)
   apply (case_tac "r_xa x")
     apply (auto)
  apply (simp add: stpx_ex_def)
  apply (auto)
   apply (rule_tac drop_weak_use_env)
  apply (case_tac "r_xb x")
    apply (auto)
  done
   
lemma stpx_ex_lift_leq_use_env: "leq_use_env (stpx_ex (lift_use_env r_s r) x) (lift_use_env (stpx_ex r_s x) r)"    
  apply (simp add: stpx_ex_def)
  apply (auto)
    apply (rule_tac leq_empty_use_env)
   apply (rule_tac drop_lift_leq_use_env)
  apply (rule_tac id_leq_use_env)
  done    

lemma well_typed_stpx_req:
  "\<lbrakk> well_typed env r_s1 e tau (comp_use_env (rem_use_env r_se x) rx2) (rem_use_env r_xe x); leq_use_env rx2_c rx2 \<rbrakk> \<Longrightarrow>
  well_typed env r_s1 e tau (comp_use_env (rem_use_env r_se x) rx2) (stpx_req (rem_use_env r_xe x) rx2_c r)"
  apply (simp add: stpx_req_def)
  apply (auto)
  apply (rule_tac well_typed_comp_req2)
    apply (auto)
   apply (rule_tac drop_leq_use_env)
   apply (rule_tac comp_leq_use_env2)
   apply (simp)
  apply (rule_tac well_typed_comp_req2)
   apply (simp)
  apply (rule_tac comp_leq_use_env2)
  apply (simp)
  done
    
    (* 
      ####################################
        P2. var case
      ####################################
    *)     

    (*
      the intuition behind this lemma is that - if x is owned by r_xe, these are trivially the same.
      - if x is not in r_xe, x is not in rx - r_ex either. since x was in rx, it must be getting subtracted out.
      this means it would be subtracted out of r_s as well, which means it cant be in r_se either. this means (lift rx2)
      will get subtracted out. since r_ex has the ability to subtract x, we know r = own. case analysis of both sides
      of the equation show that they're all the same, since rx2 will be totally annihilated under these conditions.
      - the hardest case is if x is used by r_xe.
    *)
lemma stpx_diff_req_use_env: "\<lbrakk> leq_use_env r_ex (add_use_env rx1 x r); rx x \<noteq> NoPerm; safe_use_lift rx2 r; leq_perm q r; r_xe x \<noteq> UsePerm;
  leq_use_env r_se (diff_use_env r_s r_ex); leq_use_env (diff_use_env rx r_ex) r_xe; disj_use_env (rem_use_env r_xe x) (lift_use_env rx2 r) \<rbrakk> \<Longrightarrow>
  diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 q) (r_xe x)) (end_neg_use_env r_se x rx2 r) =
  diff_use_env (comp_use_env (rem_use_env r_xe x) (lift_use_env rx2 q)) (end_neg_use_env r_se x rx2 r)"
  apply (case_tac "r_xe x \<noteq> NoPerm")
   apply (simp add: stpx_req_def)
  apply (simp add: stpx_req_def)
  apply (cut_tac r_ex="r_ex" and r_s="r_xe" and r_x="rx" and x="x" in diff_use_own)
     apply (auto)
  apply (case_tac "\<not> is_own r")
   apply (simp add: leq_use_env_def)
   apply (erule_tac x="x" in allE)
   apply (simp add: add_use_env_def)
   apply (simp add: is_own_def)
   apply (case_tac r)
     apply (auto)
  apply (cut_tac r_s="r_s" and r_x="rx" and r_ex="r_ex" and x="x" in diff_use_none)
    apply (auto)
   apply (rule_tac r_s="r_xe" in leq_use_none)
    apply (auto)
  apply (cut_tac r_s="diff_use_env r_s r_ex" and r_x="r_se" in leq_use_none)
    apply (auto)
  apply (simp add: end_neg_use_env_def)
    (* the intuition is that lift rx2 q - lift rx2 r = empty_use_env *)
  apply (rule_tac t="diff_use_env (comp_use_env (rem_use_env r_xe x) (lift_use_env rx2 q)) (lift_use_env rx2 r)" and
      s="comp_use_env (diff_use_env (rem_use_env r_xe x) (lift_use_env rx2 r)) (diff_use_env (lift_use_env rx2 q) (lift_use_env rx2 r))" in subst)
   apply (rule_tac dist_diff_comp_use_env)
  apply (cut_tac r_x="rx2" and q="q" and r="r" in cancel_diff_lift_use_env)
   apply (auto)
  apply (simp add: comp_empty_use_env2)
  done
  
lemma stpx_var_case: "
      \<lbrakk>well_typed env rx2 e' t rx2 rx2; rx1 x1a = NoPerm; is_sexp e'; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r;
        disj_use_env rx1 (lift_use_env rx2 r); add_env env x1a t x1a = Some tau; var_value_type x2a tau; leq_use_env (req_use_env x1a tau) (add_use_env rx1 x1a r);
        leq_use_env r_se (diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)); leq_use_env r_xe r_se;
        leq_use_env r_ex (add_use_env rx1 x1a r); leq_use_env (diff_use_env (req_use_env x1a tau) (comp_use_env (req_use_env x1a tau) r_ex)) r_xe\<rbrakk>
       \<Longrightarrow> well_typed env r_s1 e' tau (diff_use_env (comp_use_env (rem_use_env r_se x1a) (lift_use_env rx2 r)) (end_neg_use_env r_se x1a rx2 r))
            (diff_use_env (stpx_req (rem_use_env r_xe x1a) (lift_use_env rx2 (r_xe x1a)) (r_xe x1a)) (end_neg_use_env r_se x1a rx2 r))"
    (* - r_xe x1a \<le> r *)
  apply (case_tac "\<not> leq_perm (r_xe x1a) r")
   apply (case_tac "\<not> (\<forall> x'. leq_perm (r_xe x') (add_use_env rx1 x1a r x'))")
    apply (cut_tac r_sc="r_xe" and r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" and r_sa="add_use_env rx1 x1a r" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (rule_tac r_sb="r_se" in trans_leq_use_env)
      apply (simp_all)
    apply (simp add: leq_use_env_def)
   apply (erule_tac x="x1a" in allE)
   apply (simp add: add_use_env_def)
    (* - we split the entire proof over r_xe x1a = Use *)
  apply (case_tac "r_xe x1a = UsePerm")
   apply (auto)
   apply (simp add: stpx_req_def)
    (* - well-typedness manipulation *)
   apply (rule_tac well_typed_diff_end_perm)
    apply (rule_tac ?r_s1.0="comp_use_env (rem_use_env r_se x1a) (lift_use_env rx2 r)" in well_typed_incr_start_perm)
     apply (rule_tac well_typed_comp_req1)
      apply (rule_tac well_typed_comp_perms2)
       apply (rule_tac well_typed_lift_perms)
       apply (simp add: add_env_def)
       apply (rule_tac wt_sexp_drop_req)
         apply (simp_all)
    (* - we know that tau is unlim, because otherwise r_se = none, r_xe = none *)
       apply (case_tac "comp_use_env (req_use_env x1a tau) r_ex x1a = OwnPerm")
        apply (cut_tac r_s="add_use_env rx1 x1a r" and r_ex="comp_use_env (req_use_env x1a tau) r_ex" and x="x1a" in diff_use_none_ex)
         apply (simp)
        apply (cut_tac r_x="r_xe" and r_s="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in leq_use_none)
          apply (rule_tac r_sb="r_se" in trans_leq_use_env)
           apply (auto)
       apply (case_tac "req_use_env x1a tau x1a = OwnPerm")
        apply (simp add: comp_use_env_def)
       apply (simp add: req_use_env_def)
       apply (simp add: start_req_perm_def)
       apply (simp add: one_use_env_def)
    (* - discharging the other requirements *)
      apply (rule_tac comm_disj_use_env)
      apply (rule_tac r_s="rx1" in disj_leq_use_env1)
       apply (simp)
      apply (rule_tac r="r" in rem_add_leq_use_env)
      apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in trans_leq_use_env)
       apply (rule_tac self_diff_leq_use_env)
      apply (simp)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac dist_rem_leq_use_env)
     apply (simp)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (rule_tac end_neg_leq_use_env)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac self_comp_leq_use_env2)
    (* otherwise, simplifying stpx_req using an insane lemma *)
  apply (cut_tac r_xe="r_xe" and r_ex="comp_use_env (req_use_env x1a tau) r_ex" and ?rx1.0="rx1" and x="x1a" and r="r" and q="r_xe x1a" and
      rx="req_use_env x1a tau" and ?rx2.0="rx2" and r_se="r_se" and r_s="add_use_env rx1 x1a r" in stpx_diff_req_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (auto)
    apply (simp add: req_use_env_def)
    apply (simp add: start_req_perm_def)
    apply (simp add: one_use_env_def)
    apply (case_tac "aff_fun_ty tau")
     apply (auto)
   apply (rule_tac r_s="rx1" in disj_leq_use_env1)
    apply (simp)
   apply (rule_tac r="r" in rem_add_leq_use_env)
   apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in trans_leq_use_env)
    apply (rule_tac self_diff_leq_use_env)
   apply (rule_tac r_sb="r_se" in trans_leq_use_env)
    apply (auto)
    (* - careful manipulation *)  
  apply (rule_tac well_typed_diff_end_perm)
   apply (rule_tac ?r_s1.0="comp_use_env (rem_use_env r_se x1a) (lift_use_env rx2 r)" in well_typed_incr_start_perm)
    apply (rule_tac well_typed_comp_req1)
     apply (rule_tac well_typed_comp_perms2)
      apply (rule_tac well_typed_lift_req)
       apply (rule_tac well_typed_lift_perms)
       apply (simp add: add_env_def)
      apply (rule_tac dist_lift_leq_use_env_gen)
      apply (simp)
    (* - proving disjointness of r_se - x / rx2 (required to remove rse from end perms) [comp_perms2] *)
     apply (rule_tac comm_disj_use_env)
     apply (rule_tac r_s="rx1" in disj_leq_use_env1)
      apply (simp)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env) 
     apply (simp)
    (* - proving that removing r_xe - x from the reqs was valid [comp_req1] *)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac dist_rem_leq_use_env)
    apply (simp)
    (* - proving that downgrading the start perms was valid (rse - x) + rx2 \<le> r_s1 [incr_start_perm] *)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="rx1" in trans_leq_use_env)
     apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x1a r) (comp_use_env (req_use_env x1a tau) r_ex)" in trans_leq_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac self_comp_leq_use_env2)
    (* - proving that the very first removal of rx2 was okay *)
  apply (rule_tac end_neg_leq_use_env)
  apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac self_comp_leq_use_env2)
  done

    (* 
      ####################################
        P3. if case
      ####################################
    *) 
  
lemma dist_foil_comp_use_env: "comp_use_env (comp_use_env r_xa r_xb) (comp_use_env r_sa r_sb) = comp_use_env (comp_use_env r_xa r_sa) (comp_use_env r_xb r_sb)"    
  apply (cut_tac r_ex="comp_use_env r_xa r_xb" and r_s="r_sa" and r_x="r_sb" in dist_sq_comp_use_env)
  apply (simp)
  apply (cut_tac r_s="r_xa" and r_x="r_xb" and r_ex="r_sa" in shuffle_comp_use_env)
  apply (simp)
  apply (rule_tac t="comp_use_env (comp_use_env r_xa r_xb) r_sb" and s="comp_use_env r_xa (comp_use_env r_xb r_sb)" in subst)
   apply (rule_tac assoc_comp_use_env)
  apply (cut_tac r_s="comp_use_env r_xa r_sa" and r_x="r_xb" and r_ex="comp_use_env r_xa (comp_use_env r_xb r_sb)" in shuffle_comp_use_env)
  apply (simp)
  apply (cut_tac r_ex="comp_use_env r_xa r_sa" and r_s="r_xa" and r_x="comp_use_env r_xb r_sb" in assoc_comp_use_env)
  apply (simp)
  apply (rule_tac t="comp_use_env (comp_use_env (comp_use_env (comp_use_env r_xa r_sa) r_xa) (comp_use_env r_xb r_sb)) r_xb" and
      s="comp_use_env (comp_use_env (comp_use_env r_xa r_sa) r_xa) (comp_use_env (comp_use_env r_xb r_sb) r_xb)" in subst)
   apply (rule_tac assoc_comp_use_env)
  apply (cut_tac r_s="r_xa" and r_x="r_sa" in double_comp_use_env)
  apply (cut_tac r_s="r_xb" and r_x="r_sb" in double_comp_use_env)
  apply (simp)
  done
 
lemma foil_comp_lift_use_env: "lift_use_env r_s (comp_use_env r_xa r_xb x) = comp_use_env (lift_use_env r_s (r_xa x)) (lift_use_env r_s (r_xb x))"    
  apply (case_tac "\<not> (\<forall> x'. lift_use_env r_s (comp_use_env r_xa r_xb x) x' = comp_use_env (lift_use_env r_s (r_xa x)) (lift_use_env r_s (r_xb x)) x')")  
   apply (auto)
  apply (simp add: comp_use_env_def)
  apply (case_tac "r_xa x")
    apply (auto)
    apply (case_tac "r_xb x")
      apply (auto)
      apply (case_tac "r_s x'")
        apply (auto)
     apply (case_tac "r_s x'")
       apply (auto)
    apply (case_tac "r_s x'")
      apply (auto)
   apply (case_tac "r_xb x")
     apply (auto)
     apply (case_tac "r_s x'")
       apply (auto)
    apply (case_tac "r_s x'")
      apply (auto)
   apply (case_tac "r_s x'")
     apply (auto)
  apply (case_tac "r_s x'")
    apply (auto)
  apply (case_tac "r_xb x")
    apply (auto)
  done
    
lemma dom_lift_comp_use_env: "\<lbrakk> r = OwnPerm \<rbrakk> \<Longrightarrow> comp_use_env r_s (lift_use_env r_s r) = comp_use_env (drop_use_env r_s) (lift_use_env r_s r)"    
  apply (case_tac "\<forall> x. comp_use_env r_s (lift_use_env r_s r) x = comp_use_env (drop_use_env r_s) (lift_use_env r_s r) x")
   apply (auto)
  apply (simp add: comp_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (case_tac "r_s x")
    apply (auto)
  done
    
lemma stpxic_finish: "\<lbrakk> rx1a x \<noteq> NoPerm; rx2a x \<noteq> NoPerm \<rbrakk> \<Longrightarrow>
  stpx_ex (comp_use_env (lift_use_env rx2 (rx1a x)) (lift_use_env rx2 (rx2a x))) (comp_use_env rx1a rx2a x) =
  comp_use_env (stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x)) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))"
    (* we take care of the combined use case first *)
  apply (case_tac "comp_use_env rx1a rx2a x = UsePerm")
   apply (case_tac "\<not> rx1a x = UsePerm")
    apply (simp add: comp_use_env_def)
    apply (case_tac "rx1a x")
      apply (auto)
   apply (case_tac "\<not> rx2a x = UsePerm")
    apply (simp add: comp_use_env_def)
    apply (case_tac "rx2a x")
      apply (auto)
   apply (simp add: stpx_ex_def)
   apply (rule_tac dist_drop_comp_use_env)
    (* otherwise, we demonstrate comp_use_env rx1a rx2a x = Own *)
  apply (case_tac "comp_use_env rx1a rx2a x \<noteq> OwnPerm")
   apply (simp add: comp_use_env_def)
   apply (case_tac "rx1a x")
     apply (auto)
   apply (case_tac "rx2a x")
     apply (auto)
    (* with that, we do the final case analysis *)
  apply (simp add: stpx_ex_def)
  apply (auto)
    apply (simp add: comp_use_env_def)
    apply (case_tac "rx1a x")
      apply (auto)
    apply (case_tac "rx2a x")
      apply (auto)
   apply (cut_tac r_s="lift_use_env rx2 (rx1a x)" and r="rx2a x" in dom_lift_comp_use_env)
    apply (auto)
   apply (case_tac "rx1a x")
     apply (auto)
  apply (simp add: comm_comp_use_env)
  apply (cut_tac r_s="lift_use_env rx2 (rx2a x)" and r="rx1a x" in dom_lift_comp_use_env)
   apply (auto)
  done
    
lemma stpx_if_no_fv: "\<lbrakk>
     leq_use_env (rem_use_env r_s1 x) rx1; disj_use_env rx1 (lift_use_env rx2 r); lam_vars e \<inter> free_vars e' = {};
     well_typed (add_env env x t) r_s1 e tau r_s2 rx'; leq_perm (rx' x) r; x \<notin> free_vars e\<rbrakk>
    \<Longrightarrow> well_typed env (diff_use_env (comp_use_env (rem_use_env r_s1 x) (lift_use_env rx2 r)) (end_neg_use_env r_s2 x rx2 r)) (subst_exp e x e') tau
         (diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_s2 x rx2 r))
         (diff_use_env (stpx_req (rem_use_env rx' x) (lift_use_env rx2 (rx' x)) (rx' x)) (end_neg_use_env r_s2 x rx2 r))"
    (* no fv case *)  
  apply (rule_tac subst_type_preserve_no_fv)
   apply (rule_tac well_typed_diff_perms)
    apply (rule_tac well_typed_stpx_req)
     apply (rule_tac well_typed_comp_perms)
      apply (rule_tac well_typed_rem_perms)
       apply (rule_tac x="x" and t="t" in well_typed_add_vars_rev)
        apply (simp_all)
    apply (rule_tac r_s="rx1" in disj_leq_use_env1)
     apply (simp_all)
   apply (rule_tac dist_lift_leq_use_env_gen)
   apply (simp)
    (* prove rx2 is disjoint from free vars in e *)
  apply (simp add: own_env_vars_def)
  apply (simp add: end_neg_use_env_def)
  apply (auto)
   apply (case_tac "x = xa")
    apply (simp)
   apply (case_tac "(rem_use_env r_s1 x) xa = NoPerm")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s1" and e="e" and x="xa" in well_typed_no_fv_use)
      apply (auto)
    apply (simp add: rem_use_env_def)
   apply (case_tac "rx1 xa = NoPerm")
    apply (cut_tac r_x="rem_use_env r_s1 x" and r_s="rx1" and x="xa" in leq_use_none)
      apply (auto)
   apply (simp add: disj_use_env_def)
   apply (simp add: mini_disj_use_env_def)
  apply (simp add: empty_use_env_def)
  done
    
lemma stpx_if_case: "\<lbrakk>\<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e1 tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e1;
            lam_vars e1 \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e1 x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        \<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e2 tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e2;
            lam_vars e2 \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e2 x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        \<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e3 tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e3;
            lam_vars e3 \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e3 x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; is_sexp e'; (lam_vars e1 \<union> lam_vars e2 \<union> lam_vars e3) \<inter> free_vars e' = {};
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r);
        well_typed (add_env env x t) (add_use_env rx1 x r) e1 BoolTy r_s2 rx'; well_typed (add_env env x t) r_s2 e2 tau r_se rx1a;
        well_typed (add_env env x t) r_s2 e3 tau r_se rx2a\<rbrakk>
       \<Longrightarrow> \<exists>rx' r_s2. well_typed env r_s1 (subst_exp e1 x e') BoolTy r_s2 rx' \<and>
                      (\<exists>rx1. well_typed env r_s2 (subst_exp e2 x e') tau
                              (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)) rx1 \<and>
                             (\<exists>rx2b. well_typed env r_s2 (subst_exp e3 x e') tau
                                      (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)) rx2b \<and>
                                     diff_use_env
                                      (stpx_req (rem_use_env (comp_use_env rx1a rx2a) x) (lift_use_env rx2 (comp_use_env rx1a rx2a x)) (comp_use_env rx1a rx2a x))
                                      (end_neg_use_env r_se x rx2 r) =
                                     comp_use_env rx1 rx2b))"
    (* - prelim: rx' x \<le> r *)
  apply (case_tac "\<not> leq_perm (rx' x) r")
   apply (cut_tac r_x="rx'" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
    apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
      apply (auto)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
   apply (simp add: add_use_env_def)
    (* - prelim: rx1a x, rx2a x \<le> r *)
  apply (cut_tac r_sc="r_se" and r_sb="r_s2" and r_sa="add_use_env rx1 x r" in trans_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  apply (case_tac "\<not> leq_perm (rx1a x) r")
   apply (cut_tac r_x="rx1a" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
    apply (rule_tac r_sb="r_se" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
   apply (simp add: add_use_env_def)
  apply (case_tac "\<not> leq_perm (rx2a x) r")
   apply (cut_tac r_x="rx2a" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
    apply (rule_tac r_sb="r_se" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
   apply (simp add: add_use_env_def)
    (* x \<notin> fv e1 *)
  apply (rule_tac x="diff_use_env (stpx_req (rem_use_env rx' x) (lift_use_env rx2 (rx' x)) (rx' x)) (end_neg_use_env r_s2 x rx2 r)" in exI)
  apply (rule_tac x="diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_s2 x rx2 r)" in exI)
  apply (auto)
   apply (case_tac "x \<notin> free_vars e1")
    apply (rule_tac ?r_s1.0="diff_use_env (comp_use_env (rem_use_env rx1 x) (lift_use_env rx2 r)) (end_neg_use_env r_s2 x rx2 r)" in well_typed_incr_start_perm)
     apply (cut_tac r_s="rx1" and x="x" in self_rem_leq_use_env)
     apply (cut_tac r_s="rx1" and x="x" and r="r" in partial_rem_add_use_env)
     apply (simp)
     apply (rule_tac t="t" in stpx_if_no_fv)
           apply (auto)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_rem_leq_use_env)
    apply (rule_tac self_comp_leq_use_env2)
    (* x \<in> fv e1, induct *)
   apply (case_tac "\<not> lam_vars e1 \<inter> free_vars e' = {}")
    apply (auto)
    (* minor lemma *)
  apply (case_tac "\<not> leq_use_env (end_neg_use_env r_s2 x rx2 r) (end_neg_use_env r_se x rx2 r)")
   apply (simp add: end_neg_use_env_def)
   apply (auto)
      apply (cut_tac r="lift_use_env rx2 r" in id_leq_use_env)
      apply (simp)
     apply (cut_tac r_x="r_se" and r_s="r_s2" and x="x" in leq_use_none)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
    apply (cut_tac r="lift_use_env rx2 r" in leq_empty_use_env)
    apply (simp)
   apply (cut_tac r="empty_use_env" in id_leq_use_env)
   apply (auto)
    (* e2 case, x \<notin> fv e2  *)
  apply (rule_tac x="diff_use_env (stpx_req (rem_use_env rx1a x) (lift_use_env rx2 (rx1a x)) (rx1a x)) (end_neg_use_env r_se x rx2 r)" in exI)
  apply (auto)
   apply (case_tac "x \<notin> free_vars e2")
    apply (rule_tac ?r_s1.0="diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)" in well_typed_incr_start_perm)
     apply (rule_tac stpx_if_no_fv)
          apply (auto)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (simp)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (simp)
    (* x \<in> fv e2, well-typedness manipulation *)
   apply (case_tac "\<not> well_typed (add_env env x t) (add_use_env (rem_use_env r_s2 x) x r) e2 tau r_se rx1a")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and r_c="add_use_env (rem_use_env r_s2 x) x r" and e="e2" and 
      tau="tau" and ?r_s2.0="r_se" and rx="rx1a" in well_typed_incr_start_perm)
      apply (simp)
     apply (rule_tac r_sb="add_use_env (rem_use_env r_s2 x) x (r_s2 x)" in trans_leq_use_env)
      apply (rule_tac dist_add_leq_use_env_gen)
       apply (rule_tac id_leq_use_env)
      apply (cut_tac env="add_env env x t" and ?r_s1.0="add_use_env rx1 x r" and ?r_s2.0="r_s2" and x="x" in well_typed_spec_perm_leq)
       apply (auto)
     apply (simp add: add_use_env_def)
    apply (cut_tac r_s="r_s2" and x="x" and r="r_s2 x" in cancel_add_rem_use_env)
     apply (auto)
    apply (rule_tac id_leq_use_env)
    (* prove that we aren't subtracting rx2 *)
   apply (case_tac "r_s2 x = NoPerm")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and e="e2" and x="x" in well_typed_no_fv_use)
      apply (auto)
   apply (case_tac "\<not> end_neg_use_env r_s2 x rx2 r = empty_use_env")
    apply (simp add: end_neg_use_env_def)
   apply (auto)
   apply (cut_tac r_s="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in diff_empty_use_env2)
   apply (simp)
    (* induction requirements *)
   apply (case_tac "\<not> rem_use_env r_s2 x x = NoPerm")
    apply (simp add: rem_use_env_def)
   apply (cut_tac r="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in id_leq_use_env)
    apply (case_tac "lam_vars e2 \<inter> free_vars e' = {}")
    apply (auto)
   apply (cut_tac r_x="rem_use_env r_s2 x" and r_s="rx1" and r_ex="lift_use_env rx2 r" in disj_leq_use_env1)
     apply (simp)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* e3 case, x \<notin> fv e3  *)
  apply (rule_tac x="diff_use_env (stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_se x rx2 r)" in exI)
  apply (auto)
   apply (case_tac "x \<notin> free_vars e3")
    apply (rule_tac ?r_s1.0="diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)" in well_typed_incr_start_perm)
     apply (rule_tac stpx_if_no_fv)
          apply (auto)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (simp)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (simp)
    (* x \<in> fv e3, well-typedness manipulation *)
   apply (case_tac "\<not> well_typed (add_env env x t) (add_use_env (rem_use_env r_s2 x) x r) e3 tau r_se rx2a")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and r_c="add_use_env (rem_use_env r_s2 x) x r" and e="e3" and 
      tau="tau" and ?r_s2.0="r_se" and rx="rx2a" in well_typed_incr_start_perm)
      apply (simp)
     apply (rule_tac r_sb="add_use_env (rem_use_env r_s2 x) x (r_s2 x)" in trans_leq_use_env)
      apply (rule_tac dist_add_leq_use_env_gen)
       apply (rule_tac id_leq_use_env)
      apply (cut_tac env="add_env env x t" and ?r_s1.0="add_use_env rx1 x r" and ?r_s2.0="r_s2" and x="x" in well_typed_spec_perm_leq)
       apply (auto)
     apply (simp add: add_use_env_def)
    apply (cut_tac r_s="r_s2" and x="x" and r="r_s2 x" in cancel_add_rem_use_env)
     apply (auto)
    apply (rule_tac id_leq_use_env)
    (* prove that we aren't subtracting rx2 *)
   apply (case_tac "r_s2 x = NoPerm")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and e="e3" and x="x" in well_typed_no_fv_use)
      apply (auto)
   apply (case_tac "\<not> end_neg_use_env r_s2 x rx2 r = empty_use_env")
    apply (simp add: end_neg_use_env_def)
   apply (auto)
   apply (cut_tac r_s="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in diff_empty_use_env2)
   apply (simp)
    (* induction requirements *)
   apply (case_tac "\<not> rem_use_env r_s2 x x = NoPerm")
    apply (simp add: rem_use_env_def)
   apply (cut_tac r="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in id_leq_use_env)
    apply (case_tac "lam_vars e3 \<inter> free_vars e' = {}")
    apply (auto)
   apply (cut_tac r_x="rem_use_env r_s2 x" and r_s="rx1" and r_ex="lift_use_env rx2 r" in disj_leq_use_env1)
     apply (simp)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* final structural manipulation *)
  apply (cut_tac r_s="stpx_req (rem_use_env rx1a x) (lift_use_env rx2 (rx1a x)) (rx1a x)" and r_x="stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x)"
     and r_ex="end_neg_use_env r_se x rx2 r" in dist_diff_comp_use_env)
  apply (simp)
  apply (rule_tac t="comp_use_env (stpx_req (rem_use_env rx1a x) (lift_use_env rx2 (rx1a x)) (rx1a x)) (stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x))"
      and s="stpx_req (rem_use_env (comp_use_env rx1a rx2a) x) (lift_use_env rx2 (comp_use_env rx1a rx2a x)) (comp_use_env rx1a rx2a x)" in subst)
    (* - we prep by noting that rx1a + rx2a has a value at x *)
   apply (case_tac "comp_use_env rx1a rx2a x = NoPerm")
    apply (cut_tac r_sa="rx1a" and r_sb="rx2a" and x="x" in comp_use_none_both)
     apply (simp)
    apply (simp add: stpx_req_def)
    apply (auto)
   apply (rule_tac dist_rem_comp_use_env)
  apply (simp add: stpx_compact_conv)
  apply (simp add: stpx_compact_def)
  apply (auto)
    (* - both none case, impossible *)
     apply (cut_tac r_sa="rx1a" and r_sb="rx2a" and x="x" in comp_use_none)
       apply (simp_all)
    (* - rx2a has a value, rx1a does not *)
    apply (case_tac "\<not> comp_use_env rx1a rx2a x = rx2a x")
     apply (simp add: comp_use_env_def)
     apply (case_tac "rx2a x")
       apply (auto)
    apply (cut_tac r_ex="rem_use_env rx1a x" and r_s="rem_use_env rx2a x" and r_x="stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)" in assoc_comp_use_env)
    apply (simp)
    apply (cut_tac r_s="rx1a" and r_x="rx2a" and x="x" in dist_rem_comp_use_env)
    apply (simp)
     (* - rx1a has a value, rx2a does not *)
   apply (case_tac "\<not> comp_use_env rx1a rx2a x = rx1a x")
    apply (simp add: comp_use_env_def)
    apply (case_tac "rx1a x")
      apply (auto)
   apply (cut_tac r_s="rem_use_env rx1a x" and r_ex="rem_use_env rx2a x" and r_x="stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x)" in shuffle_comp_use_env)
   apply (simp)
   apply (cut_tac r_s="rx1a" and r_x="rx2a" and x="x" in dist_rem_comp_use_env)
   apply (simp)
    (* - rx1a and rx2a have values *)
  apply (cut_tac r_s="rx1a" and r_x="rx2a" and x="x" in dist_rem_comp_use_env)
  apply (auto)
  apply (cut_tac r_xa="rem_use_env rx1a x" and r_xb="stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x)" and
      r_sa="rem_use_env rx2a x" and r_sb="stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)" in dist_foil_comp_use_env)
  apply (simp)
  apply (cut_tac r_s="rx2" and r_xa="rx1a" and r_xb="rx2a" and x="x" in foil_comp_lift_use_env)
  apply (simp)
  apply (cut_tac ?rx2.0="rx2" and rx1a="rx1a" and rx2a="rx2a" and x="x" in stpxic_finish)
    apply (simp_all)
  done
    
    (* 
      ####################################
        P4. lam case
      ####################################
    *)     
    
lemma stpalc_nal_use_env: "\<lbrakk> r_s x = NoPerm; leq_use_env r_x (add_use_env r_s x r) \<rbrakk> \<Longrightarrow> leq_use_env (norm_use_env r_x r_s) r_s"    
  apply (simp add: leq_use_env_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (simp add: add_use_env_def)
  apply (simp add: norm_use_env_def)
  apply (case_tac "x = xa")
   apply (auto)
  done

lemma stpx_lam_case: "\<lbrakk>\<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e;
            leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; is_sexp e'; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r;
        disj_use_env rx1 (lift_use_env rx2 r); x \<in> free_vars e; x \<noteq> x1a; x1a \<notin> free_vars e'; lam_vars e \<inter> free_vars e' = {};
        well_typed (add_env (add_env env x t) x1a t1) (add_use_env rx x1a ra) e t2 r_s' r_end; aff_use_env rx a; leq_use_env rx (add_use_env rx1 x r);
        leq_use_env r_se (diff_use_env (add_use_env rx1 x r) r_ex); leq_use_env r_xe r_se; leq_use_env r_ex (add_use_env rx1 x r);
        leq_use_env (diff_use_env rx r_ex) r_xe\<rbrakk>
       \<Longrightarrow> \<exists>rx. (\<exists>r_end r_s'. well_typed (add_env env x1a t1) (add_use_env rx x1a ra) (subst_exp e x e') t2 r_s' r_end) \<and>
                aff_use_env rx a \<and>
                leq_use_env rx r_s1 \<and>
                (\<exists>r_ex. leq_use_env (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)) (diff_use_env r_s1 r_ex) \<and>
                        leq_use_env (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r))
                         (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)) \<and>
                        leq_use_env r_ex r_s1 \<and>
                        leq_use_env (diff_use_env rx r_ex)
                         (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r)))"
    (* prelim: rx x \<noteq> None *)
  apply (case_tac "rx x = NoPerm")
   apply (cut_tac env="add_env (add_env env x t) x1a t1" and ?r_s1.0="add_use_env rx x1a ra" and x="x" and e="e" in well_typed_no_fv_use)
     apply (auto)
   apply (simp add: add_use_env_def)
    (* prelim: rx x \<le> r *)
  apply (case_tac "\<not> leq_perm (rx x) r")
   apply (cut_tac r_x="rx" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
    apply (simp)
   apply (simp add: add_use_env_def)
    (* prelim: r_xe x \<le> r *)
  apply (case_tac "\<not> leq_perm (r_xe x) r")
   apply (cut_tac r_x="r_xe" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
    apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x r) r_ex" in trans_leq_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (rule_tac r_sb="r_se" in trans_leq_use_env)
    apply (simp_all)
   apply (simp add: add_use_env_def)
    (* new requirements passed in: (rx - x) + (lift rx2) *)
  apply (rule_tac x="comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))" in exI)
  apply (auto)
     apply (rule_tac x="diff_use_env (stpx_req (rem_use_env r_end x) (lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (r_end x)) (r_end x))
        (end_neg_use_env r_s' x (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x))" in exI)
     apply (rule_tac x="diff_use_env (comp_use_env (rem_use_env r_s' x) (lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x)))
        (end_neg_use_env r_s' x (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x))" in exI)
    (* - manipulating well-typedness statement to use for induction.
        env has both x and x1a added to it. so we put x on the outside.
    *)
     apply (cut_tac env="env" and x="x1a" and t="t" and y="x" and t'="t1" in almost_comm_add_env)
      apply (auto)
    (* chosen rx1: (rx + x1a ra) - x *)
    (* - we're allowed to add x to rx (after removing some original value of x to further facilitate induction) *)
     apply (case_tac "\<not> well_typed (add_env (add_env env x1a t1) x t) (add_use_env (rem_use_env (add_use_env rx x1a ra) x) x (rx x)) e t2 r_s' r_end")
      apply (cut_tac env="add_env (add_env env x1a t1) x t" and ?r_s1.0="add_use_env rx x1a ra" and r_c="add_use_env (add_use_env rx x1a ra) x (rx x)" and
        e="e" and tau="t2" and ?r_s2.0="r_s'" and rx="r_end" in well_typed_incr_start_perm)
        apply (auto)
       apply (cut_tac r_s="add_use_env rx x1a ra" and x="x" and r="rx x" in cancel_add_rem_use_env)
        apply (simp add: add_use_env_def)
       apply (auto)
      apply (cut_tac r_s="add_use_env rx x1a ra" and x="x" and r="rx x" in cancel_add_rem_use_env)
       apply (simp add: add_use_env_def)
      apply (auto)
    (* chosen rx2: (drop rx2) - x *)
    (* - manipulation of the rx2 well-typedness constraint, so that we can remove x1a from it. *)
     apply (case_tac "\<not> well_typed (add_env env x1a t1) (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) e' t
        (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a)")
      apply (cut_tac env="env" and ?r_s1.0="rx2" and ?r_s2.0="rx2" and rx="rx2" and x="x1a" and e="e'" and tau="t" and t="t1" in well_typed_add_vars)
        apply (auto)
      apply (cut_tac env="add_env env x1a t1" and rx="rx2" and e="e'" and r="rx x" in wt_sexp_drop_all_ex)
         apply (auto)
    (* - case analysis to prove rx x = None is impossible, rx x = Use implies unlim t *)
       apply (simp add: tau_drop_req_def)
       apply (case_tac "rx x")
         apply (auto)
       apply (cut_tac env="add_env (add_env env x t) x1a t1" and ?r_s1.0="add_use_env rx x1a ra" and e="e" and x="x" and t="t" in well_typed_fv_start_use)
           apply (auto)
        apply (simp add: add_env_def)
       apply (simp add: add_use_env_def)
    (* - finish with the removal *)
      apply (cut_tac env="add_env env x1a t1" and ?r_s1.0="drop_use_env_ex rx2 (rx x)" and ?r_s2.0="drop_use_env_ex rx2 (rx x)" and
        rx="drop_use_env_ex rx2 (rx x)" and x="x1a" and e="e'" and tau="t" in well_typed_rem_perms)
        apply (auto)
    (* - manual proofs of the other induction constraints *)(*
     apply (case_tac "\<not> add_env env x1a t1 x = None")
      apply (simp add: add_env_def)*)
     apply (case_tac "\<not> rem_use_env (add_use_env rx x1a ra) x x = NoPerm")
      apply (simp add: rem_use_env_def)
     apply (auto)
    (* - rx1 is removable *)
     apply (case_tac "\<not> leq_use_env (rem_use_env (add_use_env rx x1a ra) x)
      (add_use_env (comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))) x1a ra)")
      apply (cut_tac r_x="rem_use_env rx x" and r_s="comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))" and x="x1a" and r="ra" in dist_add_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (cut_tac r_s="rx" and x="x1a" and r="ra" and y="x" in almost_comm_rem_add_use_env)
       apply (auto)
    (* - disjoint-ness *)
     apply (case_tac "\<not> disj_use_env (rem_use_env (add_use_env rx x1a ra) x) (lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x))")
      apply (cut_tac r_s="rem_use_env rx x" and r_x="lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x)" and x="x1a" and r="ra" in disj_add_use_env)
        apply (simp add: rem_use_env_def)
        apply (case_tac "rx x")
          apply (auto)
       apply (rule_tac r_s="rx1" in disj_leq_use_env1)
        apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
         apply (simp)
        apply (rule_tac r_sb="lift_use_env rx2 (rx x)" in trans_leq_use_env)
         apply (rule_tac dist_lift_leq_use_env_gen)
         apply (simp)
        apply (rule_tac dist_lift_leq_use_env)
        apply (rule_tac rem_leq_use_env)
        apply (case_tac "rx x")
          apply (auto)
         apply (rule_tac self_drop_leq_use_env)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac r="r" in rem_add_leq_use_env)
       apply (simp)
      apply (cut_tac r_s="rx" and x="x1a" and r="ra" and y="x" in almost_comm_rem_add_use_env)
       apply (auto)
    (* - rx2 is removable *)
     apply (case_tac "\<not> leq_use_env (lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x))
      (add_use_env (comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))) x1a ra)")
      apply (cut_tac r_x="lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x)" and
        r_s="comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))" and x="x1a" and r="ra" in cancel_rem_add_leq_use_env) 
       apply (rule_tac self_comp_leq_use_env2)
      apply (cut_tac r_s="drop_use_env_ex rx2 (rx x)" and x="x1a" and r="rx x" in lift_rem_use_env)
      apply (auto)
    (* - rx1 + rx2 removable *)
     apply (cut_tac r_xa="rem_use_env (add_use_env rx x1a ra) x" and r_xb="lift_use_env (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x)" and
        r_s="add_use_env (comp_use_env (rem_use_env rx x) (lift_use_env (drop_use_env_ex rx2 (rx x)) (rx x))) x1a ra" in dist_comp_leq_use_env)
       apply (auto)
    (* - safety *)
     apply (case_tac "\<not> safe_use_lift (rem_use_env (drop_use_env_ex rx2 (rx x)) x1a) (rx x)")
      apply (cut_tac r_s="drop_use_env_ex rx2 (rx x)" and x="x1a" and r="rx x" in safe_lift_rem_use_env)
       apply (case_tac "rx x")
         apply (auto)
     apply (simp add: drop_use_env_def)
     apply (case_tac "rx2 xaa = OwnPerm")
      apply (auto)
    (* post-induction rx2 affinity requirement.
      - if rx x = Use then rx2 affine by construction
      - if rx x = Own then affine a
      ** the main issue is, what if e' is a lambda that does actually require some ownerships?
    *)
    apply (rule_tac aff_comp_use_env)
     apply (rule_tac aff_rem_use_env)
     apply (simp)
    apply (case_tac "rx x")
      apply (auto)
     apply (simp add: aff_use_env_def)
     apply (simp add: weak_use_env_def)
     apply (simp add: drop_use_env_def)
    apply (simp add: aff_use_env_def)
    apply (auto)
    apply (simp add: weak_use_env_def)
    
    (* the conclusion that we're being forced to draw is that an unlim lambda cannot take ownership,
      because the ownership by itself has the potential to force resource re-usage.
      - the intuition for why the substitution should work is that, if x is passed into rx, which gets
        used for the lambda, then it should drop to use permissions. now the problem is that if x
        initially had ownership permissions, then when the actual substitution is performed, it will
        inherit the full permissions. and even though it uses those permissions safely, our type system
        will balk at allowing ownership permissions to be passed into an unlim lambda.
      - the absolutely sneaky intuition for why it should still work is that we ought to vary the
        induction based on whether rx x = UsePerm or not, since we are actually allowed to vary the
        induction based on a different r.

        if rx x = UsePerm, then rx2 will not be lifted. if t is unlim, then by unlim_aff, rx2 is also non-aff
        if t is non-unlim, then we must have ownership to use it.
        and if rx x = OwnPerm, then simply a is affine.
    *)
    (* - requirements existential bound *)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (simp)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac r_sb="lift_use_env rx2 (rx x)" in trans_leq_use_env)
    apply (rule_tac dist_lift_leq_use_env_gen)
    apply (simp)
   apply (rule_tac dist_lift_leq_use_env)
   apply (case_tac "rx x")
     apply (auto)
    apply (rule_tac self_drop_leq_use_env)
   apply (rule_tac id_leq_use_env)
    (* chosen subtracter: (r_ex \ rx2) + (lift rx2) *)
  apply (rule_tac x="comp_use_env (norm_use_env (rem_use_env r_ex x) rx1) (end_neg_use_env r_se x rx2 r)" in exI)
  apply (auto)
    (* - upper bound on end permissions *)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac r_sb="diff_use_env rx1 r_ex" in trans_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac self_comp_leq_use_env1)
       apply (rule_tac norm_leq_use_env)
       apply (rule_tac self_rem_leq_use_env)
      apply (rule_tac r="r" in rem_add_leq_use_env)
      apply (rule_tac r_sb="diff_use_env (add_use_env rx1 x r) r_ex" in trans_leq_use_env)
       apply (rule_tac add_diff_leq_use_env)
      apply (simp)
     apply (rule_tac disj_diff_leq_use_env)
      apply (rule_tac disj_norm_use_env1)
       apply (rule_tac gen_mini_disj_use_env1)
       apply (rule_tac r_s="rx1" in disj_leq_use_env1)
        apply (simp)
       apply (rule_tac r="r" in rem_add_leq_use_env)
       apply (simp_all)
     apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac self_comp_leq_use_env2)
    (* - relative bound *)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac stpx_req_leq_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac dist_rem_leq_use_env)
     apply (simp)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac dist_lift_leq_use_env_gen)
    apply (simp)
    (* - subtracter validity *)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac x="x" and r="r" in stpalc_nal_use_env)
     apply (auto)
    apply (rule_tac rem_leq_use_env)
    apply (simp)
   apply (rule_tac end_neg_leq_use_env)
   apply (rule_tac self_comp_leq_use_env2)
    (* - lower bound on requirements *)
  apply (rule_tac lhs_dist_dcl_use_env)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac lhs_unroll_dcl_use_env)
   apply (rule_tac dist_diff_leq_use_env)
   apply (rule_tac r_sb="diff_use_env (rem_use_env rx x) (rem_use_env r_ex x)" in trans_leq_use_env)
    apply (rule_tac t="diff_use_env (rem_use_env rx x) (rem_use_env r_ex x)" and s="rem_use_env (diff_use_env rx r_ex) x" in subst)
     apply (rule_tac dist_diff_rem_use_env)
    apply (rule_tac stpx_req_leq_use_env2)
    apply (rule_tac dist_rem_leq_use_env)
    apply (simp)
   apply (rule_tac diff_norm_leq_use_env)
   apply (rule_tac r="r" in rem_add_leq_use_env)
   apply (simp)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac diff_leq_use_env)
    (* - the hardest part of the inequality, depends on r_xe x. say that r_xe x \<noteq> none *)
  apply (case_tac "r_xe x \<noteq> NoPerm")
    (* - say that r_se x \<noteq> None. then r_ex x \<noteq> Own, and we have rx x \<le> r_xe x, which allows us to dissolve the inequalities *)
   apply (case_tac "r_se x \<noteq> NoPerm")
    apply (case_tac "r_ex x = OwnPerm")
     apply (cut_tac r_x="r_se" and r_s="diff_use_env (add_use_env rx1 x r) r_ex" and x="x" in leq_use_none)
       apply (simp)
      apply (rule_tac diff_use_none_ex)
      apply (simp_all)
    apply (cut_tac r_x="rx" and r_ex="r_ex" and r_s="r_xe" and x="x" in diff_use_leq)
      apply (simp_all)
    apply (rule_tac dist_diff_leq_use_env)
    apply (case_tac "rx x")
      apply (auto)
     apply (simp add: stpx_req_def)
     apply (auto)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac drop_leq_use_env)
     apply (rule_tac self_lift_leq_use_env)
    apply (simp add: stpx_req_def)
    apply (auto)
    apply (rule_tac comp_leq_use_env2)
    apply (case_tac "r_xe x")
      apply (auto)
    apply (rule_tac id_leq_use_env)
    (* - r_se x \<noteq> None since r_xe \<le> r_se *)
   apply (cut_tac r_x="r_xe" and r_s="r_se" and x="x" in spec_leq_perm)
    apply (simp)
   apply (case_tac "r_xe x")
     apply (auto)
    (* - otherwise r_xe x = None. in this case r_ex x = Own, which means that r_se = None + r = Own. which means rx2 annihilates *)
  apply (rule_tac r_sb="diff_use_env (lift_use_env rx2 (rx x)) (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
   apply (case_tac "r_ex x \<noteq> OwnPerm")
    apply (case_tac "diff_use_env rx r_ex x = NoPerm")
     apply (simp add: diff_use_env_def)
     apply (simp add: minus_use_env_def)
     apply (simp add: neg_use_env_def)
     apply (case_tac "r_ex x")
       apply (auto)
      apply (case_tac "rx x")
        apply (auto)
     apply (case_tac "rx x")
       apply (auto)
    apply (cut_tac r_x="diff_use_env rx r_ex" and r_s="r_xe" and x="x" in leq_use_none)
      apply (simp_all)
   apply (cut_tac r_s="add_use_env rx1 x r" and r_ex="r_ex" and x="x" in diff_use_none_ex)
    apply (simp)
   apply (cut_tac r_x="r_se" and r_s="diff_use_env (add_use_env rx1 x r) r_ex" and x="x" in leq_use_none)
     apply (simp_all)
   apply (case_tac "\<not> is_own r")
    apply (cut_tac r_x="r_ex" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
     apply (simp)
    apply (simp add: add_use_env_def)
    apply (simp add: is_own_def)
    apply (case_tac r)
      apply (simp_all)
   apply (simp add: end_neg_use_env_def)
   apply (cut_tac r_s="rx2" and q="rx x" and r="r" in ann_lift_use_env)
    apply (simp add: is_own_def)
   apply (simp)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac dist_lift_leq_use_env)
  apply (case_tac "rx x")
    apply (auto)
   apply (rule_tac self_drop_leq_use_env)
  apply (rule_tac id_leq_use_env)
  done

    (* 
      ####################################
        P5. app case
      ####################################
    *)         

    (* 
      the end-permissions will be r_s3 + rx2 that has already had
       x & (lift rx2) removed from it.
      
      from here we have to further subtract
        (rx1a + rx2) - x - (lift rx2)
        & lift [(rx2a + rx2) - x - (lift rx2)]
      
      in theory we can easily consolidate this to
       ((r_s3 + rx2) - rx1a - rx2a) - x - (lift rx2)
      
      which allows us to satisfy the upper bound quite summarily
      
      the requirements (assuming that they arent squashed) will be
       (rx1a + rx2) - x - (lift rx2)
       + (rx2a + rx2) - x - (lift rx2)
       - ((rx1a + rx2) - x - (lift rx2))
       - lift ((rx2a + rx2) - x - (lift rx2))
      *)    

lemma stpa_incr_ind_perm: "\<lbrakk> well_typed env (add_use_env r_s1 x r) e tau r_s2 rx; leq_perm r p \<rbrakk> \<Longrightarrow> well_typed env (add_use_env r_s1 x p) e tau r_s2 rx"    
  apply (rule_tac well_typed_incr_start_perm)
   apply (auto)
    apply (simp add: leq_use_env_def)
  apply (simp add: add_use_env_def)
  apply (auto)
  apply (case_tac "r_s1 xa")
    apply (auto)
  done
    
(*
  say that r = Use, but ra = Own. this means that r_s1 x is a use, which means rx2a x is a use.
  however, (lift rx2a ra) x = Own. since (lift rx2a ra) is subtractable from r_s1 x, we have a
  contradiction
*)  
    
lemma prec_diff_leq_use_env: "\<lbrakk> leq_use_env (diff_use_env r_s r_xa) (diff_use_env r_s r_xb); leq_use_env (diff_use_env r_s r_xa) (diff_use_env r_s r_xc) \<rbrakk> \<Longrightarrow>
  leq_use_env (diff_use_env r_s r_xa) (diff_use_env r_s (comp_use_env r_xb r_xc))"
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: minus_use_env_def)
  apply (simp add: neg_use_env_def)
  apply (simp add: comp_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (case_tac "r_s x")
    apply (auto)
   apply (case_tac "r_xa x")
     apply (auto)
    apply (case_tac "r_xb x")
      apply (auto)
     apply (case_tac "r_xc x")
       apply (auto)
    apply (case_tac "r_xc x")
      apply (auto)
   apply (case_tac "r_xb x")
     apply (auto)
    apply (case_tac "r_xc x")
      apply (auto)
   apply (case_tac "r_xc x")
     apply (auto)
  apply (case_tac "r_xa x")
    apply (auto)
   apply (case_tac "r_xb x")
     apply (auto)
    apply (case_tac "r_xc x")
      apply (auto)
   apply (case_tac "r_xc x")
     apply (auto)
  apply (case_tac "r_xb x")
    apply (auto)
   apply (case_tac "r_xc x")
     apply (auto)
  apply (case_tac "r_xc x")
    apply (auto)
  done
    
definition stpxac_lift_res where
  "stpxac_lift_res p q r = (p = NoPerm \<or> leq_perm q r)"
    
lemma stpxac_lift_order: "\<lbrakk> safe_use_lift r_s r; leq_use_env (lift_use_env rx2a ra) (add_use_env rx1 x r) \<rbrakk> \<Longrightarrow> stpxac_lift_res (rx2a x) ra r"    
  apply (simp add: stpxac_lift_res_def)
  apply (auto)
  apply (case_tac "rx2a x \<noteq> NoPerm")
   apply (auto)
  apply (cut_tac r_x="lift_use_env rx2a ra" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
   apply (simp)
  apply (simp add: add_use_env_def)
  apply (case_tac r)
    apply (auto)
  apply (case_tac ra)
    apply (auto)
  done
    
lemma stpx_app_case: "\<lbrakk>\<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e1 tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e1;
            lam_vars e1 \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e1 x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        \<And>env x tau t rx1 r_se r_xe r_s1 rx2 r.
           \<lbrakk>well_typed (add_env env x t) (add_use_env rx1 x r) e2 tau r_se r_xe; well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e2;
            lam_vars e2 \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r)\<rbrakk>
           \<Longrightarrow> well_typed env r_s1 (subst_exp e2 x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r));
        well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; is_sexp e'; (lam_vars e1 \<union> lam_vars e2) \<inter> free_vars e' = {};
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1; safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r);
        well_typed (add_env env x t) (add_use_env rx1 x r) e1 (FunTy t1 tau ra a) r_s2 rx1a; well_typed (add_env env x t) r_s2 e2 t1 r_s3 rx2a;
        leq_use_env r_se (diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)); safe_use_lift rx2a ra; safe_type t1 ra;
        leq_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_s3; disj_use_env rx1a (lift_use_env rx2a ra); leq_use_env r_xe r_se;
        leq_use_env r_ex (add_use_env rx1 x r); leq_use_env (app_req rx1a rx2a ra tau r_ex) r_xe\<rbrakk>
       \<Longrightarrow> \<exists>t1 ra a r_s2 rx1.
              well_typed env r_s1 (subst_exp e1 x e') (FunTy t1 tau ra a) r_s2 rx1 \<and>
              (\<exists>rx2a r_s3.
                  well_typed env r_s2 (subst_exp e2 x e') t1 r_s3 rx2a \<and>
                  (\<exists>r_ex. leq_use_env (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
                           (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2a ra)) r_ex)) \<and>
                          safe_use_lift rx2a ra \<and>
                          safe_type t1 ra \<and>
                          leq_use_env (comp_use_env rx1 (lift_use_env rx2a ra)) r_s3 \<and>
                          disj_use_env rx1 (lift_use_env rx2a ra) \<and>
                          leq_use_env (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r))
                           (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r)) \<and>
                          leq_use_env r_ex r_s1 \<and>
                          leq_use_env (app_req rx1 rx2a ra tau r_ex)
                           (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r))))"
    (* - prelim: r_s3 \<le> rx1 + x (used frequently) *)
  apply (cut_tac r_sc="r_s3" and r_sb="r_s2" and r_sa="add_use_env rx1 x r" in trans_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
    (* - prelim: rx1a x \<le> r *)
  apply (case_tac "\<not> leq_perm (rx1a x) r")
   apply (case_tac "\<not> (\<forall> x'. leq_perm (rx1a x') (add_use_env rx1 x r x'))")
    apply (cut_tac r_sc="rx1a" and r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" and r_sa="add_use_env rx1 x r" in trans_leq_use_env)
      apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
       apply (auto)
     apply (rule_tac self_comp_leq_use_env1)
    apply (simp add: leq_use_env_def)
   apply (erule_tac x="x" in allE)
   apply (simp add: add_use_env_def)
    (* - prelim: rx2a x \<le> r *)
  apply (case_tac "\<not> leq_perm (rx2a x) r")
   apply (case_tac "\<not> (\<forall> x'. leq_perm (rx2a x') (add_use_env rx1 x r x'))")
    apply (cut_tac r_sc="rx2a" and r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" and r_sa="add_use_env rx1 x r" in trans_leq_use_env)
      apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
       apply (auto)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac self_lift_leq_use_env)
    apply (simp add: leq_use_env_def)
   apply (erule_tac x="x" in allE)
  apply (simp add: add_use_env_def)
    (* - prelim: either rx2a x = None or ra \<le> r *)
  apply (cut_tac ?rx1.0="rx1" and rx2a="rx2a" and x="x" and r="r" and ra="ra" in stpxac_lift_order)
    apply (simp)
   apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (simp_all)
   apply (rule_tac self_comp_leq_use_env2)
    (* initial e1 existentials *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="ra" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_s2 x rx2 r)" in exI)
  apply (rule_tac x="diff_use_env (stpx_req (rem_use_env rx1a x) (lift_use_env rx2 (rx1a x)) (rx1a x)) (end_neg_use_env r_s2 x rx2 r)" in exI)
  apply (auto)
    (* x \<notin> fv e1 *)
   apply (case_tac "x \<notin> free_vars e1")
    apply (rule_tac ?r_s1.0="comp_use_env (rem_use_env rx1 x) (lift_use_env rx2 r)" in well_typed_incr_start_perm)
     apply (rule_tac subst_type_preserve_no_fv)
      apply (rule_tac well_typed_diff_end_perm)
       apply (rule_tac well_typed_stpx_req)
       apply (rule_tac well_typed_comp_perms)
        apply (cut_tac r_s="rx1" and x="x" and r="r" in partial_rem_add_use_env)
        apply (simp)
        apply (rule_tac well_typed_rem_perms)
         apply (rule_tac x="x" and t="t" in well_typed_add_vars_rev)
           apply (simp_all)
       apply (rule_tac disj_rem_use_envx)
       apply (simp)
      apply (rule_tac dist_lift_leq_use_env_gen)
      apply (simp)
     apply (rule_tac end_neg_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_rem_leq_use_env)
    apply (rule_tac self_comp_leq_use_env2)
    (* x \<in> fv e1, induction on e1 *)
   apply (case_tac "\<not> lam_vars e1 \<inter> free_vars e' = {}")
    apply (auto)
    (* x \<notin> fv e2. *)
  apply (rule_tac x="diff_use_env (stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_s3 x rx2 r)" in exI)
  apply (rule_tac x="diff_use_env (comp_use_env (rem_use_env r_s3 x) (lift_use_env rx2 r)) (end_neg_use_env r_s3 x rx2 r)" in exI)
  apply (auto)
   apply (case_tac "x \<notin> free_vars e2")
    apply (rule_tac ?r_s1.0="diff_use_env (comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)) (end_neg_use_env r_s3 x rx2 r)" in well_typed_incr_start_perm)
     apply (rule_tac subst_type_preserve_no_fv)
      apply (rule_tac well_typed_diff_perms)
       apply (rule_tac well_typed_stpx_req)
        apply (rule_tac well_typed_comp_perms)
         apply (cut_tac r_s="r_s2" and x="x" and r="r" in partial_rem_add_use_env)
         apply (simp)
         apply (rule_tac well_typed_rem_perms)
          apply (rule_tac x="x" and t="t" in well_typed_add_vars_rev)
            apply (rule_tac ?r_s1.0="add_use_env r_s2 x (r_s2 x)" in well_typed_incr_start_perm)
             apply (cut_tac r_s="r_s2" and x="x" in self_add_use_env)
             apply (simp_all)
        apply (rule_tac dist_add_leq_use_env_gen)
         apply (rule_tac id_leq_use_env)
        apply (cut_tac r_x="r_s2" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
        apply (simp add: add_use_env_def)
       apply (rule_tac r_s="rx1" in disj_leq_use_env1)
        apply (simp)
       apply (rule_tac r="r" in rem_add_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac dist_lift_leq_use_env_gen)
      apply (simp)    
    (* - prove rx2 is disjoint from free vars in e2 *)
     apply (simp add: own_env_vars_def)
     apply (simp add: end_neg_use_env_def)
     apply (case_tac "r_s3 x = NoPerm")
      apply (auto)
      apply (case_tac "x = xa")
       apply (auto)
      apply (case_tac "r_s2 xa = NoPerm")
       apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and e="e2" and x="xa" in well_typed_no_fv_use)
         apply (auto)
      apply (case_tac "rx1 xa = NoPerm")
       apply (cut_tac r_x="r_s2" and r_s="add_use_env rx1 x r" and x="xa" in leq_use_none)
         apply (rule_tac well_typed_perm_leq)
         apply (simp_all)
       apply (simp add: add_use_env_def)
      apply (simp add: disj_use_env_def)
      apply (auto)
      apply (simp add: mini_disj_use_env_def)
     apply (simp add: empty_use_env_def)
    (* - the rest of the bounds *)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac dist_end_neg_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* x \<in> fv e2. induction on e2 *)
    (* - we start by proving that r_s2 x \<noteq> None *)
   apply (case_tac "r_s2 x = NoPerm")
    apply (cut_tac env="add_env env x t" and ?r_s1.0="r_s2" and x="x" and e="e2" in well_typed_no_fv_use)
      apply (auto)
    (* - with that in mind we can remove the subtraction from the start permissions *)
   apply (case_tac "\<not> end_neg_use_env r_s2 x rx2 r = empty_use_env")
    apply (simp add: end_neg_use_env_def)
   apply (simp)
   apply (cut_tac r_s="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in diff_empty_use_env2)
   apply (simp)
    (* - starts with well-typedness statement where rx1 = rem_use_env r_s2 x *)
   apply (case_tac "\<not> well_typed (add_env env x t) (add_use_env (rem_use_env r_s2 x) x (r_s2 x)) e2 t1 r_s3 rx2a")
    apply (cut_tac r_s="r_s2" and x="x" and r="r_s2 x" in cancel_add_rem_use_env)
     apply (simp_all)
   apply (cut_tac env="add_env env x t" and ?r_s1.0="rem_use_env r_s2 x" and x="x" and r="r_s2 x" and p="r" in stpa_incr_ind_perm)
     apply (auto)
    apply (cut_tac ?r_s2.0="r_s2" and ?r_s1.0="add_use_env rx1 x r" and env="add_env env x t" and e="e1" in well_typed_perm_leq)
     apply (simp_all)
    apply (case_tac "\<not> (\<forall>xa. leq_perm (r_s2 xa) (add_use_env rx1 x r xa))")
     apply (simp add: leq_use_env_def)
     apply (auto)
    apply (erule_tac x="x" in allE)
    apply (simp add: add_use_env_def)
   apply (case_tac "\<not> lam_vars e2 \<inter> free_vars e' = {}")
    apply (auto)
   apply (case_tac "\<not> rem_use_env r_s2 x x = NoPerm")
    apply (simp add: rem_use_env_def)
   apply (cut_tac r="comp_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)" in id_leq_use_env)
   apply (case_tac "\<not> disj_use_env (rem_use_env r_s2 x) (lift_use_env rx2 r)")
    apply (cut_tac r_x="rem_use_env r_s2 x" and r_s="rx1" and r_ex="lift_use_env rx2 r" in disj_leq_use_env1)
      apply (simp)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    (* - final manipulation *)
  apply (rule_tac x="comp_use_env (norm_use_env (rem_use_env r_ex x) rx1) (end_neg_use_env r_se x rx2 r)" in exI)
  apply (auto)
    (* - put the lhs into a form where comp can be eliminated *)
        apply (rule_tac lhs_dist_dcl_use_env)
    (* - transformations useful for the entire inequality *)
    (* - proving the inequality for r_se, starting with canonicalizing rhs *)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac rhs_fold_dcl_use_env)
    (* - create a target in-between for utilizing the r_se \<le> r_s3 inequality *)
         apply (rule_tac r_sb="diff_use_env (diff_use_env (rem_use_env r_s3 x) (comp_use_env
          (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)) (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
          apply (rule_tac lhs_fold_dcl_use_env)
    (* - creating an in-between splitting the set into parts that can be subsumed by the original
        and parts that are disjoint *)
          apply (rule_tac r_sb="diff_use_env (diff_use_env (rem_use_env r_s3 x)
            (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) (comp_use_env (norm_use_env (rem_use_env r_ex x) rx1) (end_neg_use_env r_se x rx2 r))))
            (comp_use_env (stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x)) (lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra))" in trans_leq_use_env)
    (* - prove that this step is valid *)
           apply (rule_tac lhs_fold_dcl_use_env)
           apply (rule_tac dist_diff_leq_use_env_gen)
            apply (rule_tac self_comp_leq_use_env1)
           apply (rule_tac dist_comp_leq_use_env)
            apply (rule_tac comp_leq_use_env1)
            apply (rule_tac comp_leq_use_env2)
            apply (rule_tac comp_leq_use_env2)
            apply (rule_tac dist_end_neg_leq_use_env)
            apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" in trans_leq_use_env)
             apply (rule_tac self_diff_leq_use_env)
            apply (simp)
           apply (rule_tac dist_comp_leq_use_env)
            apply (rule_tac dist_comp_leq_use_env)
             apply (rule_tac diff_leq_use_env)
             apply (rule_tac stpx_req_leq_use_env3)
             apply (rule_tac dist_comp_leq_use_env)
              apply (rule_tac comp_leq_use_env1)
              apply (rule_tac comp_leq_use_env1)
              apply (rule_tac comp_leq_use_env1)
              apply (rule_tac self_rem_leq_use_env)
             apply (rule_tac comp_leq_use_env2)
             apply (rule_tac self_comp_leq_use_env1)
            apply (rule_tac r_sb="lift_use_env (comp_use_env (rem_use_env rx2a x) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))) ra" in trans_leq_use_env)
             apply (cut_tac r_s="rem_use_env rx2a x" and r_x="stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)" and r="ra" in lift_comp_use_env)
             apply (simp)
             apply (rule_tac dist_comp_leq_use_env)
              apply (rule_tac comp_leq_use_env1)
              apply (rule_tac comp_leq_use_env1)
              apply (rule_tac comp_leq_use_env2)
              apply (rule_tac dist_lift_leq_use_env)
              apply (rule_tac self_rem_leq_use_env)
             apply (rule_tac comp_leq_use_env2)
             apply (rule_tac self_comp_leq_use_env2)
            apply (rule_tac dist_lift_leq_use_env)
            apply (rule_tac diff_leq_use_env)
            apply (rule_tac stpx_req_leq_use_env3)
            apply (rule_tac id_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac self_comp_leq_use_env2)
    (* - remove disjoint subtractant *)
          apply (rule_tac disj_diff_leq_use_env)
           apply (rule_tac comm_disj_use_env)
           apply (rule_tac r_s="rx1" in disj_leq_use_env1)
            apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
             apply (simp)
            apply (rule_tac dist_comp_leq_use_env)
             apply (rule_tac stpx_ex_leq_use_env)
             apply (rule_tac dist_lift_leq_use_env_gen)
             apply (auto)
    (* / if rx2a x = None, the lhs is empty *)
            apply (case_tac "rx2a x = NoPerm")
             apply (simp add: stpx_ex_def)
             apply (simp add: lift_empty_use_env)
             apply (rule_tac leq_empty_use_env)
    (* / if ra \<le> r, (which it is by prelim) then we can remove the lift *)
            apply (case_tac "leq_perm ra r")
             apply (rule_tac lhs_lift_leq_use_env_gen)
              apply (rule_tac stpx_ex_leq_use_env)
              apply (rule_tac dist_lift_leq_use_env_gen)
              apply (simp_all)
            apply (simp add: stpxac_lift_res_def)
           apply (rule_tac diff_leq_use_env)
           apply (rule_tac rem_add_leq_use_env)
           apply (simp)
    (* - prove that the in-between set subtracted subsumes the original set *)
          apply (rule_tac dist_diff_leq_use_env_gen)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac self_comp_leq_use_env1)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac comp_leq_use_env2)
           apply (rule_tac norm_leq_use_env)
           apply (rule_tac self_rem_leq_use_env)
          apply (rule_tac self_comp_leq_use_env2)
    (* - use r_se \<le> r_s3 identity *)
         apply (rule_tac dist_diff_leq_use_env)
         apply (case_tac "\<not> diff_use_env (rem_use_env r_s3 x) (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex) =
          rem_use_env (diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)) x")
          apply (cut_tac r_s="r_s3" and r_x="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and x="x" in comm_diff_rem_use_env)
          apply (auto)
         apply (rule_tac dist_rem_leq_use_env)
         apply (simp)
    (* - proving the inequality for rx2, creating an in-between splitting the set into parts that can be subsumed by the original
        and parts that are disjoint, being extremely careful to preserve certain properties of rx2 *)
        apply (rule_tac r_sb="diff_use_env (lift_use_env rx2 r)
          (comp_use_env (comp_use_env (end_neg_use_env r_se x rx2 r) (comp_use_env
            (diff_use_env (stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x)) (end_neg_use_env r_s2 x rx2 r))
            (diff_use_env (lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra) (end_neg_use_env r_s3 x rx2 r))))
          (comp_use_env (rem_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) x) (norm_use_env (rem_use_env r_ex x) rx1)))" in trans_leq_use_env)
         apply (rule_tac rhs_fold_dcl_use_env)
    (* - prove that the subtracting set subsumes the original *)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac dist_end_neg_leq_use_env)
          apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" in trans_leq_use_env)
           apply (rule_tac self_diff_leq_use_env)
          apply (simp)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac r_sb="diff_use_env (comp_use_env (rem_use_env rx1a x) (stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x))) (end_neg_use_env r_s2 x rx2 r)" in trans_leq_use_env)
            apply (rule_tac lhs_dist_dcl_use_env)
            apply (rule_tac dist_comp_leq_use_env)
             apply (rule_tac diff_leq_use_env)
             apply (rule_tac comp_leq_use_env2)
             apply (rule_tac comp_leq_use_env1)
             apply (rule_tac dist_rem_leq_use_env)
             apply (rule_tac self_comp_leq_use_env1)
            apply (rule_tac comp_leq_use_env1)
            apply (rule_tac comp_leq_use_env2)
            apply (rule_tac self_comp_leq_use_env1)
           apply (rule_tac dist_diff_leq_use_env)
           apply (rule_tac stpx_req_leq_use_env3)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac r_sb="lift_use_env (diff_use_env (comp_use_env (rem_use_env rx2a x) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))) (end_neg_use_env r_s3 x rx2 r)) ra" in trans_leq_use_env)
           apply (rule_tac t="diff_use_env (comp_use_env (rem_use_env rx2a x) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))) (end_neg_use_env r_s3 x rx2 r)" and
            s="comp_use_env (diff_use_env (rem_use_env rx2a x) (end_neg_use_env r_s3 x rx2 r)) (diff_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_s3 x rx2 r))" in subst)
            apply (rule_tac dist_diff_comp_use_env)
           apply (cut_tac r_s="diff_use_env (rem_use_env rx2a x) (end_neg_use_env r_s3 x rx2 r)" and r_x="diff_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_s3 x rx2 r)" and r="ra" in lift_comp_use_env)
           apply (simp)
           apply (rule_tac dist_comp_leq_use_env)
            apply (rule_tac comp_leq_use_env2)
            apply (rule_tac comp_leq_use_env1)
            apply (rule_tac r_sb="rem_use_env (lift_use_env rx2a ra) x" in trans_leq_use_env)
             apply (rule_tac dist_rem_leq_use_env)
             apply (rule_tac self_comp_leq_use_env2)
            apply (rule_tac t="rem_use_env (lift_use_env rx2a ra) x" and s="lift_use_env (rem_use_env rx2a x) ra" in subst)
             apply (rule_tac lift_rem_use_env)
            apply (rule_tac dist_lift_leq_use_env)
            apply (rule_tac self_diff_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac comp_leq_use_env2)
           apply (rule_tac comp_leq_use_env2)
           apply (rule_tac t="diff_use_env (lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra) (end_neg_use_env r_s3 x rx2 r)" and
             s="lift_use_env (diff_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_s3 x rx2 r)) ra" in subst)
            apply (rule_tac outer_lift_diff_use_env)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac dist_lift_leq_use_env)
          apply (rule_tac dist_diff_leq_use_env)
          apply (rule_tac stpx_req_leq_use_env3)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env2)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac comp_leq_use_env1)
         apply (rule_tac self_comp_leq_use_env1)
    (* - prove the disjointness of the second term to annihilate it *)
        apply (rule_tac rhs_unroll_dcl_use_env)
        apply (rule_tac disj_diff_leq_use_env)
         apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
          apply (rule_tac r_s="rx1" in disj_leq_use_env1)
           apply (simp)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac r="r" in rem_add_leq_use_env)
           apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
            apply (simp_all)
          apply (rule_tac norm_leq_use_env)
          apply (rule_tac rem_add_leq_use_env)
          apply (simp_all)
         apply (rule_tac self_diff_leq_use_env)
    (* - lastly we have to get rid of the actual subtractants. rx2 presents a number of challenges. *)
        apply (rule_tac prec_diff_leq_use_env)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac prec_diff_leq_use_env)
    (* - if r = Use, then this inequality is trivial because rx2 is weak. *)
         apply (case_tac "\<not> is_own r")
          apply (case_tac r)
            apply (auto)
           apply (rule_tac rhs_weak_leq_use_env)
            apply (rule_tac weak_diff_use_env)
            apply (simp add: stpx_ex_def)
            apply (auto)
              apply (simp add: weak_use_env_def)
              apply (simp add: empty_use_env_def)
             apply (rule_tac drop_weak_use_env)
            apply (case_tac "rx1a x")
              apply (simp_all)
           apply (rule_tac self_diff_leq_use_env)
          apply (simp add: is_own_def)
    (* - if r_se x = None, then rx2 will annihilate itself *)
         apply (case_tac "r_se x = NoPerm")
          apply (case_tac "end_neg_use_env r_se x rx2 r \<noteq> lift_use_env rx2 r")
           apply (simp add: end_neg_use_env_def)
          apply (simp)
          apply (cut_tac r_s="rx2" and q="r" and r="r" in ann_lift_use_env)
           apply (simp add: is_own_def)
          apply (simp)
          apply (rule_tac leq_empty_use_env)
    (* - if r_se x \<noteq> None, rx1a x \<noteq> Own *)
         apply (case_tac "rx1a x = OwnPerm")
          apply (case_tac "\<not> comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex x = OwnPerm")
           apply (simp add: comp_use_env_def)
          apply (simp)
          apply (cut_tac r_x="r_se" and r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" and x="x" in leq_use_none)
            apply (simp)
           apply (rule_tac diff_use_none_ex)
           apply (simp_all)
    (* - based on this we claim the subtractant is weak *)
         apply (rule_tac rhs_weak_leq_use_env)
          apply (rule_tac weak_diff_use_env)
          apply (simp add: stpx_ex_def)
          apply (auto)
            apply (simp add: weak_use_env_def)
            apply (simp add: empty_use_env_def)
           apply (rule_tac drop_weak_use_env)
          apply (case_tac "rx1a x")
            apply (simp_all)
         apply (rule_tac self_diff_leq_use_env)
    (* - say that rx2a x = None, we claim then that the subtractant is weak *)
        apply (case_tac "rx2a x")
          apply (simp_all)
          apply (simp add: stpx_ex_def)
          apply (rule_tac rhs_weak_leq_use_env)
           apply (rule_tac weak_diff_use_env)
           apply (rule_tac weak_lift_empty_use_env)
          apply (rule_tac self_diff_leq_use_env)
    (* - otherwise say that rx2a x = Use. say that r = Use. then ra = Use, because lift rx2a ra x \<le> (rx + x: r) x *)
         apply (case_tac "r = UsePerm")
          apply (case_tac "ra \<noteq> UsePerm")
           apply (cut_tac r_x="lift_use_env rx2a ra" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
            apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
             apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
              apply (simp_all)
            apply (rule_tac self_comp_leq_use_env2)
           apply (simp add: add_use_env_def)
           apply (case_tac ra)
             apply (auto)
    (* - then we can again show the subtractant is weak *)
          apply (rule_tac rhs_weak_leq_use_env)
           apply (rule_tac weak_diff_use_env)
           apply (simp add: stpx_ex_def)
           apply (rule_tac drop_weak_use_env)
          apply (rule_tac self_diff_leq_use_env)
    (* - if r_se x = None, then all of rx2 will be subtracted out *)
         apply (case_tac "r_se x = NoPerm")
          apply (case_tac "end_neg_use_env r_se x rx2 r \<noteq> lift_use_env rx2 r")
           apply (simp add: end_neg_use_env_def)
          apply (simp)
          apply (cut_tac r_s="rx2" and q="r" and r="r" in ann_lift_use_env)
           apply (case_tac r)
             apply (simp_all)
          apply (rule_tac leq_empty_use_env)
    (* - if r_se x \<noteq> None, then we once again show that ra = Use, since r_se \<le> r_s3 - (lift rx2 ra) *)
         apply (case_tac "ra = OwnPerm")
          apply (cut_tac r_x="r_se" and r_s="diff_use_env r_s3 (lift_use_env rx2a ra)" and x="x" in spec_leq_perm)
           apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" in trans_leq_use_env)
            apply (rule_tac dist_diff_leq_use_env_gen)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac comp_leq_use_env1)
            apply (rule_tac self_comp_leq_use_env2)
           apply (simp)
          apply (case_tac "is_own (lift_use_env rx2a ra x)")
           apply (cut_tac r_s="r_s3" and r_ex="lift_use_env rx2a ra" and x="x" in diff_use_none_ex)
            apply (simp add: is_own_def)
           apply (simp)
           apply (case_tac "r_se x")
             apply (simp_all)
          apply (simp add: is_own_def)
    (* - with that in mind, we can again show that the subtractant is weak *)
         apply (case_tac ra)
           apply (auto)
         apply (rule_tac rhs_weak_leq_use_env)
          apply (rule_tac weak_diff_use_env)
          apply (simp add: stpx_ex_def)
          apply (rule_tac drop_weak_use_env)
         apply (rule_tac self_diff_leq_use_env)
    (* - lastly we show that if rx2a x = OwnPerm, r_se x = None *)
        apply (case_tac "\<not> r_se x = NoPerm")
         apply (cut_tac r_s="r_s3" and r_ex="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and x="x" in diff_use_none_ex)
          apply (simp add: comp_use_env_def)
          apply (case_tac ra)
            apply (auto)
          apply (case_tac "rx1a x")
            apply (auto)
         apply (cut_tac r_x="r_se" and r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" and x="x" in leq_use_none)
           apply (simp_all)
    (* - with that we can show the rx2 completely subtracts itself out *)
        apply (case_tac "\<not> end_neg_use_env r_se x rx2 r = lift_use_env rx2 r")
         apply (simp add: end_neg_use_env_def)
        apply (auto)
        apply (cut_tac r_s="rx2" and q="r" and r="r" in ann_lift_use_env)
         apply (case_tac r)
           apply (auto)
        apply (rule_tac leq_empty_use_env)
    (* lift safety *)
       apply (rule_tac safe_lift_diff_use_env)
       apply (rule_tac r_s="comp_use_env (rem_use_env rx2a x) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))" in safe_lift_leq_use_env)
        apply (rule_tac stpx_req_leq_use_env3)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac safe_lift_comp_use_env)
        apply (rule_tac r_s="rx2a" in safe_lift_leq_use_env)
         apply (rule_tac self_rem_leq_use_env)
        apply (simp)
       apply (case_tac ra)
         apply (auto)
       apply (simp add: stpx_ex_def)
       apply (case_tac "rx2a x")
         apply (auto)
        apply (simp add: empty_use_env_def)
       apply (simp add: drop_use_env_def)
       apply (case_tac "rx2 xa")
         apply (auto)
    (* subtractibility bounds p1 *)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac diff_leq_use_env)
       apply (rule_tac disj_diff_leq_use_env)
        apply (case_tac "r_s3 x = NoPerm")
         apply (simp add: end_neg_use_env_def)
         apply (case_tac "rx1a x \<noteq> NoPerm")
          apply (cut_tac r_x="rx1a" and r_s="r_s3" and x="x" in spec_leq_perm)
           apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
            apply (simp)
           apply (rule_tac self_comp_leq_use_env1)
          apply (case_tac "rx1a x")
            apply (auto)
         apply (simp add: stpx_req_def)
         apply (rule_tac comm_disj_use_env)
         apply (rule_tac r_s="rx1" in disj_leq_use_env1)
          apply (simp)
         apply (rule_tac r="r" in rem_add_leq_use_env)
         apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
          apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
           apply (simp_all)
         apply (rule_tac self_comp_leq_use_env1)
        apply (simp add: end_neg_use_env_def)
        apply (rule_tac disj_empty_use_env2)
       apply (rule_tac stpx_req_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac dist_rem_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac self_comp_leq_use_env1)
       apply (rule_tac comp_leq_use_env2)
       apply (rule_tac dist_lift_leq_use_env_gen)
       apply (simp)
    (* - part 2 *)
      apply (cut_tac r_s="stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x)" and r_x="end_neg_use_env r_s3 x rx2 r" and r="ra" in outer_lift_diff_use_env)
      apply (simp)
      apply (rule_tac dist_diff_leq_use_env)
    (* - prove the lhs, which is necessary for both cases *)
      apply (case_tac "\<not> leq_use_env (lift_use_env (rem_use_env rx2a x) ra) (rem_use_env r_s3 x)")
       apply (cut_tac r_s="rx2a" and x="x" and r="ra" in lift_rem_use_env)
       apply (simp)
       apply (cut_tac r_x="lift_use_env rx2a ra" and r_s="r_s3" and x="x" in dist_rem_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac comp_leq_use_env2)
       apply (simp)
    (* - if rx2a x = None this case is easy *)
      apply (case_tac "rx2a x = NoPerm")
       apply (simp add: stpx_req_def)
       apply (rule_tac comp_leq_use_env1)
       apply (simp)
    (* - otherwise, conservatively assume lift rx2 is used *)
      apply (rule_tac r_sb="lift_use_env (comp_use_env (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x))) ra" in trans_leq_use_env)
       apply (cut_tac r_s="rem_use_env rx2a x" and r_x="lift_use_env rx2 (rx2a x)" and r="ra" in lift_comp_use_env)
       apply (simp)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (simp)
    (* we know (lift rx2a ra x) is subtractible from r_s3
      which means r = OwnPerm unless both ra + x are use.
      therefore we expect (lift (lift rx2 ..) ra) to be
      subtractible from (lift rx2 r) *)    
       apply (case_tac "r = UsePerm")
        apply (simp)
        apply (case_tac "\<not> lift_use_env rx2 (rx2a x) = rx2")
         apply (case_tac "rx2a x")
           apply (auto)
        apply (cut_tac r_x="lift_use_env rx2a ra" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
         apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
          apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
           apply (simp_all)
         apply (rule_tac self_comp_leq_use_env2)
        apply (simp add: add_use_env_def)
        apply (case_tac "ra = OwnPerm")
         apply (case_tac "rx2a x")
           apply (simp_all)
        apply (case_tac "ra")
          apply (simp_all)
        apply (rule_tac self_comp_leq_use_env2)
    (* - if r is not a Use, then rx2 is maximally lifted *)
       apply (case_tac "\<not> is_own r")
        apply (simp add: is_own_def)
        apply (case_tac r)
          apply (simp_all)
       apply (rule_tac comp_leq_use_env2)
       apply (rule_tac lhs_lift_leq_use_env)
        apply (rule_tac lhs_lift_leq_use_env)
         apply (rule_tac self_lift_leq_use_env)
        apply (simp_all)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac stpx_req_leq_use_env)
      apply (rule_tac id_leq_use_env)
    (* disjoint-ness *)
     apply (rule_tac r_s="comp_use_env (rem_use_env rx1a x) (stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x))" in disj_leq_use_env1)
      apply (rule_tac disj_comp_use_env1)
       apply (rule_tac r_s="comp_use_env (lift_use_env rx2a ra) (lift_use_env (stpx_ex (lift_use_env rx2 r) (rx2a x)) ra)" in disj_leq_use_env2)
        apply (rule_tac disj_comp_use_env2)
         apply (rule_tac disj_rem_use_envx)
         apply (simp)
        apply (case_tac "rx2a x = NoPerm")
         apply (simp add: stpx_ex_def)
         apply (simp add: lift_empty_use_env)
         apply (rule_tac disj_empty_use_env1)
        apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
         apply (rule_tac r_s="rx1" in disj_leq_use_env1)
          apply (simp)
         apply (rule_tac r="r" in rem_add_leq_use_env)
         apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
          apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
           apply (simp_all)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac r_sb="lift_use_env (lift_use_env rx2 r) ra" in trans_leq_use_env)
         apply (rule_tac lhs_lift_leq_use_env_gen)
          apply (rule_tac id_leq_use_env)
         apply (simp add: stpxac_lift_res_def)
        apply (rule_tac dist_lift_leq_use_env)
        apply (rule_tac stpx_ex_leq_use_env)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac t="comp_use_env (lift_use_env rx2a ra) (lift_use_env (stpx_ex (lift_use_env rx2 r) (rx2a x)) ra)" and
          s="lift_use_env (comp_use_env rx2a (stpx_ex (lift_use_env rx2 r) (rx2a x))) ra" in subst)
        apply (rule_tac lift_comp_use_env)
       apply (rule_tac dist_lift_leq_use_env)
       apply (rule_tac diff_leq_use_env)
       apply (rule_tac stpx_req_leq_use_env3)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac self_rem_leq_use_env)
       apply (rule_tac comp_leq_use_env2)
       apply (rule_tac dist_stpx_ex_leq_use_env2)
       apply (rule_tac dist_lift_leq_use_env_gen)
       apply (simp)
      apply (rule_tac r_s="comp_use_env (lift_use_env (rem_use_env rx2a x) ra) (lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra)" in disj_leq_use_env2)
       apply (rule_tac disj_comp_use_env2)
        apply (rule_tac comm_disj_use_env)
        apply (rule_tac r_s="rx1" in disj_leq_use_env1)
         apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
          apply (simp)
         apply (rule_tac stpx_ex_leq_use_env)
         apply (rule_tac dist_lift_leq_use_env_gen)
         apply (simp)
        apply (cut_tac r_s="rx2a" and x="x" and r="ra" in lift_rem_use_env)
        apply (simp)
        apply (rule_tac r="r" in rem_add_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
         apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
          apply (simp_all)
        apply (rule_tac self_comp_leq_use_env2)
       apply (case_tac "is_own ra")
        apply (case_tac "rx2a x \<noteq> NoPerm")
         apply (case_tac "rx1a x \<noteq> NoPerm")
          apply (case_tac "\<not> mini_disj_use_env (lift_use_env rx2a ra) rx1a")
           apply (simp add: disj_use_env_def)
          apply (simp add: mini_disj_use_env_def)
          apply (simp add: is_own_def)
         apply (case_tac "\<not> stpx_ex (lift_use_env rx2 (rx1a x)) (rx1a x) = empty_use_env")
          apply (simp add: stpx_ex_def)
         apply (simp_all)
         apply (rule_tac disj_empty_use_env2)
        apply (case_tac "\<not> stpx_ex rx2 NoPerm = empty_use_env")
         apply (simp add: stpx_ex_def)
        apply (simp add: lift_empty_use_env)
        apply (rule_tac disj_empty_use_env1)
       apply (simp add: is_own_def)
       apply (case_tac "\<not> lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra = stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)")
        apply (case_tac ra)
          apply (simp_all)
       apply (rule_tac r_xa="rx1a" and r_xb="rx2a" and x="x" in stpx_ex_disj_use_env)
       apply (rule_tac r_s="lift_use_env rx2a ra" in disj_leq_use_env2)
        apply (simp)
       apply (rule_tac self_lift_leq_use_env)
      apply (rule_tac t="comp_use_env (lift_use_env (rem_use_env rx2a x) ra) (lift_use_env (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x)) ra)" and
        s="lift_use_env (comp_use_env (rem_use_env rx2a x) (stpx_ex (lift_use_env rx2 (rx2a x)) (rx2a x))) ra" in subst)
       apply (rule_tac lift_comp_use_env)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac diff_leq_use_env)
      apply (rule_tac stpx_req_leq_use_env3)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac stpx_req_leq_use_env3)
     apply (rule_tac id_leq_use_env)
    (* relative bound *)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac stpx_req_leq_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac dist_rem_leq_use_env)
     apply (simp)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac dist_lift_leq_use_env_gen)
    apply (cut_tac r_x="r_xe" and r_s="add_use_env rx1 x r" and x="x" in spec_leq_perm)
     apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" in trans_leq_use_env)
      apply (rule_tac diff_leq_use_env)
      apply (simp)
     apply (rule_tac r_sb="r_se" in trans_leq_use_env)
      apply (simp_all)
    apply (simp add: add_use_env_def)
    (* valid subtracter *)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac norm_leq_use_env)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac comp_leq_use_env2)
   apply (simp add: end_neg_use_env_def)
   apply (auto)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac leq_empty_use_env)
    (* - prelim: common inequality *)
  apply (cut_tac r_sc="comp_use_env rx1a (lift_use_env rx2a ra)" and r_sb="r_s3" and r_sa="add_use_env rx1 x r" in trans_leq_use_env)
    apply (auto)
    (* requirements bound *)
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac leq_empty_use_env)
    (* - we start by merging together rx1a + rx2a, since their inequality is proved in the same way
      of special note is the choice of (rx1a + rx2a x) as the marker for whether rx2 exists + r_se as the indicator for when to remove rx2
    *)
  apply (rule_tac r_sb="diff_use_env (diff_use_env (comp_use_env (rem_use_env (comp_use_env rx1a rx2a) x)
     (stpx_ex (lift_use_env rx2 (comp_use_env rx1a rx2a x)) (comp_use_env rx1a rx2a x))) (end_neg_use_env r_s2 x rx2 r))
           (comp_use_env
             (comp_use_env (diff_use_env (stpx_req (rem_use_env rx1a x) (lift_use_env rx2 (rx1a x)) (rx1a x)) (end_neg_use_env r_s2 x rx2 r))
               (lift_use_env (diff_use_env (stpx_req (rem_use_env rx2a x) (lift_use_env rx2 (rx2a x)) (rx2a x)) (end_neg_use_env r_s3 x rx2 r)) ra))
             (comp_use_env (norm_use_env (rem_use_env r_ex x) rx1) (end_neg_use_env r_se x rx2 r)))" in trans_leq_use_env)
    (* - we start by canonicalizing *)
   apply (rule_tac lhs_fold_dcl_use_env)
   apply (rule_tac lhs_dist_dcl_use_env)
    (* - restructure rhs stpx_req use to a more convenient form*)
   apply (rule_tac r_sb="diff_use_env (comp_use_env (rem_use_env r_xe x) (stpx_ex (lift_use_env rx2 (r_xe x)) (r_xe x))) (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (simp add: stpx_req_def)
    apply (simp add: stpx_ex_def)
    apply (auto)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac id_leq_use_env)
    (* - work out the inequality for rx1a + rx2a, re-canonicalizing *)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="diff_use_env (rem_use_env r_xe x) (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac id_leq_use_env)
    apply (rule_tac r_sb="diff_use_env (diff_use_env (rem_use_env (comp_use_env rx1a rx2a) x) (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) (rem_use_env r_ex x)))
      (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
    apply (rule_tac r_sb="diff_use_env (diff_use_env (rem_use_env (comp_use_env rx1a rx2a) x) (rem_use_env (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex) x))
      (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
      apply (rule_tac t="diff_use_env (rem_use_env (comp_use_env rx1a rx2a) x) (rem_use_env (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex) x)" and
      s="rem_use_env (diff_use_env (comp_use_env rx1a rx2a) (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)) x" in subst)
       apply (rule_tac dist_diff_rem_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac dist_rem_leq_use_env)
      apply (simp)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac id_leq_use_env)
     apply (cut_tac r_s="comp_use_env rx1a (lift_use_env rx2a ra)" and r_x="r_ex" and x="x" in dist_rem_comp_use_env)
     apply (simp)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac self_rem_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    (* - before we continue, we have to specifically deal with the norm-ed r_ex *)
    apply (rule_tac rhs_fold_dcl_use_env)
    apply (rule_tac rhs_flip_use_env)
    apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac lhs_flip_use_env)
    apply (rule_tac lhs_unroll_dcl_use_env)
    apply (rule_tac diff_norm_leq_use_env_gen)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
      apply (simp_all)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac self_comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac self_lift_leq_use_env)
    (* we prove that the subtracting set contains the original set *)
    apply (rule_tac fold_dcl_use_env)
    apply (rule_tac lhs_fold_dcl_use_env)
    apply (rule_tac lhs_fold_rem_use_env)
    apply (rule_tac lhs_fold_dcl_use_env)
    apply (rule_tac rhs_fold_rem_use_env)
    apply (rule_tac rhs_fold_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac x="x" in lhs_rem_leq_use_env)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac disj_diff_leq_use_env)
       apply (rule_tac comm_disj_use_env)
       apply (rule_tac r_s="rx1" in disj_leq_use_env1)
        apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
         apply (simp)
        apply (simp add: end_neg_use_env_def)
        apply (auto)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac leq_empty_use_env)
       apply (rule_tac r="r" in rem_add_leq_use_env)
       apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac stpx_req_leq_use_env2)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac x="x" in lhs_rem_leq_use_env)
     apply (rule_tac t="rem_use_env (lift_use_env rx2a ra) x" and s="lift_use_env (rem_use_env rx2a x) ra" in subst)
      apply (rule_tac lift_rem_use_env)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac dist_lift_leq_use_env)
     apply (rule_tac disj_diff_leq_use_env)
      apply (rule_tac comm_disj_use_env)
      apply (rule_tac r_s="rx1" in disj_leq_use_env1)
       apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
        apply (simp)
       apply (simp add: end_neg_use_env_def)
       apply (auto)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac leq_empty_use_env)
      apply (rule_tac r="r" in rem_add_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1a (lift_use_env rx2a ra)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac self_lift_leq_use_env)
     apply (rule_tac stpx_req_leq_use_env2)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac self_comp_leq_use_env1)
    (* work out the inequality for rx2. we need to use the end_neg subtractant to show that (rx1a + rx2a) x \<le> r_xe x *)
   apply (rule_tac r_sb="diff_use_env (stpx_ex (lift_use_env rx2 (comp_use_env rx1a rx2a x)) (comp_use_env rx1a rx2a x))
      (end_neg_use_env r_se x rx2 r)" in trans_leq_use_env)
    apply (rule_tac rhs_dist_dcl_use_env)
    apply (rule_tac comp_leq_use_env2)
    (* if (rx1a + rx2a) x \<le> r_xe x, then we can prove easily *)
    apply (case_tac "leq_perm (comp_use_env rx1a rx2a x) (r_xe x)")
     apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac dist_stpx_ex_leq_use_env)
      apply (simp)
     apply (rule_tac id_leq_use_env)
    (* then (rx1a + rx2a) x \<noteq> None trivially *)
    apply (case_tac "comp_use_env rx1a rx2a x = NoPerm")
     apply (simp)
    (* else, say that r_xe x = None. then global r_ex = Own, which means r = Own. which means we can annihilate *)
    apply (case_tac "r_xe x = NoPerm")
     apply (case_tac "comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex x \<noteq> OwnPerm")
      apply (cut_tac r_x="comp_use_env rx1a rx2a" and r_ex="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and r_s="r_xe" and x="x" in diff_use_leq)
        apply (simp_all)
     apply (case_tac "\<not> is_own r")
      apply (cut_tac r_x="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and r_s="add_use_env rx1 x r" and x="x" in leq_use_own)
        apply (simp)
       apply (rule_tac dist_comp_leq_use_env)
        apply (simp_all)
      apply (simp add: add_use_env_def)
      apply (simp add: is_own_def)
     apply (case_tac "\<not> end_neg_use_env r_xe x rx2 r = lift_use_env rx2 r")
      apply (simp add: end_neg_use_env_def)
     apply (simp)
     apply (rule_tac r_sb="diff_use_env (lift_use_env rx2 (comp_use_env rx1a rx2a x)) (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (cut_tac r_s="rx2" and q="comp_use_env rx1a rx2a x" and r="r" in ann_lift_use_env)
       apply (simp add: is_own_def)
      apply (simp)
      apply (rule_tac leq_empty_use_env)
     apply (cut_tac r_x="r_se" and r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" and x="x" in leq_use_none)
       apply (simp)
      apply (rule_tac diff_use_none_ex)
      apply (simp)
     apply (case_tac "\<not> end_neg_use_env r_se x rx2 r = lift_use_env rx2 r")
      apply (simp add: end_neg_use_env_def)
     apply (simp)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac stpx_ex_leq_use_env)
     apply (rule_tac id_leq_use_env)
    (* - this eliminates (rx1a + rx2a) x = Use. *)
    apply (case_tac "comp_use_env rx1a rx2a x = UsePerm")
     apply (case_tac "r_xe x")
       apply (simp_all)
    (* - (rx1a + rx2a) x = Own means r_se = None which means r_xe = None, a contradiction *)
    apply (cut_tac r_s="r_s3" and r_ex="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and x="x" in diff_use_none_ex)
     apply (case_tac "\<not> comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex x = OwnPerm")
      apply (cut_tac r_x="comp_use_env rx1a rx2a" and r_s="comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex" and x="x" in leq_use_own)
        apply (case_tac "comp_use_env rx1a rx2a x")
          apply (simp_all)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac self_comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac self_lift_leq_use_env)
    apply (cut_tac r_x="r_xe" and r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_ex)" and x="x" in leq_use_none)
      apply (rule_tac r_sb="r_se" in trans_leq_use_env)
       apply (simp_all)
   apply (rule_tac dist_diff_leq_use_env_gen)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac self_comp_leq_use_env2)
    (* - prove that the initial merge step was valid *)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac stpx_req_leq_use_env3)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac dist_rem_leq_use_env)
      apply (rule_tac self_comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac dist_stpx_ex_leq_use_env)
     apply (rule_tac x="x" in spec_leq_perm)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac dist_diff_leq_use_env_gen)
    apply (rule_tac stpx_req_leq_use_env3)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac dist_rem_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac dist_stpx_ex_leq_use_env)
    apply (rule_tac x="x" in spec_leq_perm)
    apply (rule_tac self_comp_leq_use_env2)
   apply (rule_tac dist_end_neg_leq_use_env)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  apply (rule_tac id_leq_use_env)
  done

    (* 
      ####################################
        P6. statement of substitution type preservation
      ####################################
    *)        
    
      (*
      we develop a notion of an "affine" function because otherwise we have no way of determining a
      function that can be freely used v. one restricted by owned values in the closure.

      this gives us a notion of affine vs unlimited substitution type preservation that motivates this lemma.

      the other notable constraint of this lemma is that it requires e' to have the same starting and end
      permissions. through another lemma, we know that any well-typed s-exp can be typed in such a way, so
      this lemma will be completed later by manipulating the permissions to allow for arbitrary ending
      permissions.
    *)
    
    (*
      - e' is given static permissions. the start and end permissions must be the same to ensure that we know
          substituting it into an expression will not consume any unexpected permissions. the requirements must
          also be the same in order to ensure that it can be substituted even after some permissions have been
          removed.
        -- the idea is that the requirements for e' will still be disjoint from the requirements for e, since
          both requirements were fully contained within the original end permissions, and new permissions come
          from outside the end permissions.  
    *)
  
lemma subst_type_preserve_x: "\<lbrakk> well_typed (add_env env x t) (add_use_env rx1 x r) e tau r_se r_xe;
  well_typed env rx2 e' t rx2 rx2; rx1 x = NoPerm; x \<in> free_vars e; is_sexp e';
  lam_vars e \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s1;
  safe_use_lift rx2 r; disj_use_env rx1 (lift_use_env rx2 r) \<rbrakk> \<Longrightarrow>
  well_typed env r_s1 (subst_exp e x e') tau (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) (end_neg_use_env r_se x rx2 r))
    (diff_use_env (stpx_req (rem_use_env r_xe x) (lift_use_env rx2 (r_xe x)) (r_xe x)) (end_neg_use_env r_se x rx2 r))"
  apply (induct e arbitrary: env x tau t rx1 r_se r_xe r_s1 rx2 r)
       apply (auto)
    (* var case *)
        apply (rule_tac stpx_var_case)
                    apply (auto)
    (* if cases 1-3. *)
       apply (rule_tac stpx_if_case)
                   apply (auto)
      apply (rule_tac stpx_if_case)
                  apply (auto)
     apply (rule_tac stpx_if_case)
                 apply (auto)
    (* lambda case. *)
    apply (rule_tac stpx_lam_case)
                     apply (auto)
    (* app case 1. x \<in> free_vars e1. *)
   apply (rule_tac stpx_app_case)
                     apply (auto)
    (* app case 2. x \<in> free_vars e2. *)
  apply (rule_tac stpx_app_case)
                    apply (auto)
  done

end