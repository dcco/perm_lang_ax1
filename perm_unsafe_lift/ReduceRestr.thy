theory ReduceRestr
  imports GenSubEnv WTLemma ResMapDisj ReduceWTS
begin
  
    (* setup for an important lemma, which states that s + env restricted to part of an rs_map should remain well-typed. *)
    
definition restr_env where
  "restr_env s rs_map = (\<lambda> x. if lookup_mem rs_map x = None then None else s x)"  
  
definition np_restr_env where
  "np_restr_env env rs_map = (\<lambda> x. if lookup_mem rs_map x = None \<and> non_prim_entry env x then None else env x)"    
  
lemma restr_sub_env: "\<lbrakk> sub_env s env; non_prim_env env \<rbrakk> \<Longrightarrow> sub_env (restr_env s rs_map) (np_restr_env env rs_map)"  
  apply (simp add: sub_env_def)
  apply (auto)
  apply (simp add: restr_env_def)
  apply (simp add: np_restr_env_def)
  apply (auto)
  apply (case_tac "lookup_mem rs_map x")
   apply (auto)
  apply (simp add: non_prim_env_def)
  apply (simp add: non_prim_entry_def)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (case_tac "env x")
   apply (auto)
  done
  
lemma restr_disj_res_map: "\<lbrakk> valid_res_map s rs_map; lookup_mem rs_map x = Some (r_s, rs_map');
  lookup_res rs_map' x = empty_use_env \<rbrakk> \<Longrightarrow> disj_res_map rs_map'"
  apply (induct rs_map arbitrary: s)
   apply (auto)
  apply (case_tac "x1 = x")
   apply (auto)
   apply (rule_tac x="x" and r_s="r_s" in disj_add_res_map_rev)
    apply (simp add: add_mem_def)
    apply (simp add: valid_res_map_def)
   apply (simp)
  apply (simp add: valid_res_map_def)
    (* - disjointness for induction *)
  apply (cut_tac rs_map="rs_map" and x="x1" and r_s="x2" in disj_add_res_map_rev)
    apply (simp add: add_mem_def)
   apply (simp add: scope_res_map_def)
   apply (simp add: fresh_map_var_def)
   apply (simp add: lookup_res_def)
    (* - containment for induction *)
  apply (cut_tac rs_map="rs_map" and x="x1" and r_s="x2" and s="s" in add_sub_res_map_rev)
    apply (simp add: add_mem_def)
   apply (simp add: scope_res_map_def)
   apply (simp add: fresh_map_var_def)
    (* - scope containment for induction *)
  apply (cut_tac rs_map="rs_map" and x="x1" and r_s="x2" in add_scope_res_map_rev)
   apply (simp add: add_mem_def)
  apply (auto)
  done
    
lemma restr_sub_res_map: "\<lbrakk> sub_res_map s rs_map; scope_res_map rs_map;
  lookup_mem rs_map x = Some (r_s, rs_map') \<rbrakk> \<Longrightarrow> sub_res_map (restr_env s rs_map') rs_map'"
  apply (cut_tac rs_map="rs_map" and rs_map'="rs_map'" and x="x" and r_s="r_s" in self_scope_use_env_ih2)
    apply (auto)
  apply (simp add: sub_res_map_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
   apply (simp add: sub_scope_use_env_def)
   apply (erule_tac x="xa" in allE)
   apply (auto)
   apply (simp add: restr_env_def)
   apply (case_tac "lookup_mem rs_map' xa")
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (simp add: restr_env_def)
  done
    
lemma restr_valid_res_map: "\<lbrakk> valid_res_map s rs_map; lookup_mem rs_map x = Some (r_s, rs_map') \<rbrakk> \<Longrightarrow> valid_res_map (restr_env s rs_map') rs_map'"
  apply (simp add: valid_res_map_def)
  apply (auto)
    apply (rule_tac restr_disj_res_map)
      apply (simp add: valid_res_map_def)
     apply (auto)
    apply (cut_tac rs_map="rs_map" and x="x" in scope_res_map_fresh_lookup)
      apply (auto)
    apply (simp add: fresh_map_var_def)
    apply (simp add: lookup_res_def)
   apply (rule_tac restr_sub_res_map)
     apply (auto)
  apply (rule_tac self_scope_res_map)
   apply (auto)
  done
  
lemma dist_restr_contain_env: "\<lbrakk> sub_scope_use_env rs_map rs_map' \<rbrakk> \<Longrightarrow> contain_env (restr_env r_s rs_map) (restr_env r_s rs_map')"    
  apply (simp add: sub_scope_use_env_def)
  apply (simp add: contain_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (case_tac "restr_env r_s rs_map' x")
   apply (auto)
   apply (simp add: restr_env_def)
   apply (case_tac "lookup_mem rs_map' x")
    apply (auto)
  apply (simp add: restr_env_def)
  done
  
lemma np_restr_add_contain_env: "\<lbrakk> contain_env r_s r_x \<rbrakk> \<Longrightarrow> contain_env (add_env (np_restr_env r_s rs_map) x t) (np_restr_env (add_env r_x x t) rs_map)"    
  apply (simp add: contain_env_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (case_tac "np_restr_env (add_env r_x x t) rs_map xa")
   apply (auto)
    (* if x = xa, we know that rs_map has an entry, it's just a matter of showing that it's the same entry. *)
  apply (case_tac "x = xa")
   apply (case_tac "np_restr_env (add_env r_x x t) rs_map xa \<noteq> Some t")
    apply (simp add: add_env_def)
    apply (simp add: np_restr_env_def)
    apply (case_tac "lookup_mem rs_map xa = None \<and> non_prim_entry (\<lambda>x'. if xa = x' then Some t else r_x x') xa")
     apply (auto)
   apply (simp add: add_env_def)
    (* otherwise, we know rs_map xa = None or r_x has a prim entry.  *)
  apply (simp add: np_restr_env_def)
  apply (case_tac "lookup_mem rs_map xa = None \<and> non_prim_entry (add_env r_x x t) xa")
   apply (auto)
   apply (simp add: add_env_def)
  apply (simp add: add_env_def)
  apply (simp add: non_prim_entry_def)
  done
    
lemma np_restr_add_contain_env2: "\<lbrakk> contain_env r_s r_x \<rbrakk> \<Longrightarrow> contain_env (add_env (np_restr_env r_s rs_map) x t) (np_restr_env (add_env r_x x t) (add_mem rs_map x r_c))"     
  apply (simp add: contain_env_def)
  apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (case_tac "np_restr_env (add_env r_x x t) (add_mem rs_map x r_c) xa")
   apply (auto)
    (* if x = xa, then since x wasn't restricted in the original, it wont be restricted here either *)
  apply (case_tac "x = xa")
   apply (simp add: add_env_def)
   apply (simp add: np_restr_env_def)
   apply (auto)
   apply (case_tac "lookup_mem (add_mem rs_map x r_c) x")
    apply (simp add: add_mem_def)
   apply (auto)
    (* for x \<noteq> xa, since xa wasn't restricted in the original, either it has a lookup in rs_map or it is a prim entry *)
  apply (simp add: np_restr_env_def)
  apply (case_tac "lookup_mem (add_mem rs_map x r_c) xa = None \<and> non_prim_entry (add_env r_x x t) xa")
   apply (auto)
    (* if you can find it in rs_map, you can find it here too *)
   apply (simp add: add_env_def)
   apply (simp add: add_mem_def)
    (* if it is prim, it will be prim in the new result as well *)
  apply (simp add: add_env_def)
  apply (simp add: non_prim_entry_def)
  done    
    
lemma restr_env_eq: "\<lbrakk> sub_res_map s rs_map; sub_env s env \<rbrakk> \<Longrightarrow> restr_env env rs_map = env"    
  apply (case_tac "\<forall> x. restr_env env rs_map x = env x")  
   apply (auto)
  apply (simp add: restr_env_def)
  apply (case_tac "lookup_mem rs_map x = None")
   apply (auto)
  apply (simp add: sub_env_def)
  apply (simp add: sub_res_map_def)
  done
    
    (* attempt to show restricting the env to rs_map is acceptable. *)(*
lemma well_typed_restr_ih: "\<lbrakk> sub_res_map s rs_map; sub_env s env (*scope_res_map rs_map; scope_use_env rs_map r_s1;*)
  well_typed env r_s1 v tau r_s2 rx; contain_env env' (np_restr_env env rs_map) \<rbrakk> \<Longrightarrow> well_typed env' r_s1 v tau r_s2 rx"        
  apply (induct v arbitrary: env env' tau r_s1 r_s2 rx rs_map)
        apply (auto)
    (* var case p1. we must show the de-referenced name will still exist. *)
      apply (case_tac "\<not> non_prim_entry env (deref_name x1a x2a)")
       apply (simp add: np_restr_env_def)
       apply (simp add: contain_env_def)
       apply (erule_tac x="deref_name x1a x2a" in allE)
       apply (auto)
      apply (case_tac "r_s1 x1a = NoPerm")
       apply (cut_tac r_x="ereq_use_env x1a tau" and r_s="r_s1" and x="x1a" in leq_use_none)
         apply (auto)
       apply (cut_tac x="x1a" and tau="tau" in ereq_use_none)
        apply (simp add: non_prim_entry_def)
       apply (auto)
      apply (simp add: scope_use_env_def)
      apply (erule_tac x="x1a" in allE)
      apply (auto)
      apply (simp add: contain_env_def)
      apply (erule_tac x="x1a" in allE)
      apply (case_tac "env' x1a")
       apply (auto)
       apply (simp add: np_restr_env_def)
      apply (simp add: np_restr_env_def)
    (* pair case *)
     apply (rule_tac x="r_s2a" in exI)
     apply (rule_tac x="r_s3" in exI)
     apply (rule_tac x="rx1" in exI)
     apply (auto)
     apply (rule_tac x="rx2" in exI)
     apply (auto)
     apply (cut_tac r_x="r_s2a" and r_s="r_s1" and rs_map="rs_map" in trans_scope_use_env2)
       apply (simp)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
    (* if case *)
    apply (rule_tac x="rx'" in exI)
    apply (rule_tac x="r_s2a" in exI)
    apply (auto)
    apply (cut_tac r_x="r_s2a" and r_s="r_s1" and rs_map="rs_map" in trans_scope_use_env2)
      apply (simp)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac x="rx1" in exI)
    apply (auto)
    apply (rule_tac x="rx2" in exI)
    apply (auto)
    (* lam case *)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
   apply (rule_tac x="r_end" in exI)
   apply (rule_tac x="r_s'" in exI)
    (* - split over x1a in rs_map *)
  apply (case_tac "fresh_map_var rs_map x1a")
    (* - containment for induction *)
    apply (cut_tac env_c="np_restr_env (add_env env x1a t1) (add_mem rs_map x1a empty_use_env)" and
      env_b="add_env (np_restr_env env rs_map) x1a t1" and env_a="add_env env' x1a t1" in trans_contain_env)
      apply (rule_tac dist_add_contain_env)
      apply (simp)
     apply (rule_tac np_restr_add_contain_env2)
     apply (rule_tac id_contain_env)
    (* - scoping for induction *)
    apply (cut_tac rs_map="rs_map" and r_s="rxa" and x="x1a" and r="r" and r_c="empty_use_env" in dist_add_scope_use_env)
     apply (rule_tac r_s="r_s1" in trans_scope_use_env2)
      apply (simp_all)
    (* - scoping for induction p2 *)
    apply (cut_tac rs_map="rs_map" and x="x1a" and r_s="empty_use_env" in add_scope_res_map)
        apply (auto)
     apply (simp add: strong_use_env_def)
     apply (simp add: empty_use_env_def)
    apply (rule_tac empty_scope_use_env)
    (* if x1a is in rs_map, we have a simpler containment induction *)
   apply (cut_tac env_c="np_restr_env (add_env env x1a t1) rs_map" and
      env_b="add_env (np_restr_env env rs_map) x1a t1" and env_a="add_env env' x1a t1" in trans_contain_env)
     apply (rule_tac dist_add_contain_env)
     apply (simp)
    apply (rule_tac np_restr_add_contain_env)
    apply (rule_tac id_contain_env)
    (* - scoping for induction *)
   apply (cut_tac rs_map="rs_map" and r_s="rxa" and x="x1a" and r="r" in add_scope_use_env)
     apply (rule_tac r_s="r_s1" in trans_scope_use_env2)
      apply (simp_all)
   apply (simp add: fresh_map_var_def)
    (* app case *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="r_s2a" in exI)
  apply (rule_tac x="rx1" in exI)
  apply (auto)
  apply (rule_tac x="rx2" in exI)
  apply (rule_tac x="r_s3" in exI)
  apply (auto)
  apply (cut_tac r_x="r_s2a" and r_s="r_s1" and rs_map="rs_map" in trans_scope_use_env2)
    apply (simp)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  done*)
    
lemma well_typed_restr: "\<lbrakk> (*scope_res_map rs_map; scope_use_env rs_map r_s1; non_prim_env env; *)
  sub_res_map s rs_map; sub_env s env; well_typed env r_s1 v tau r_s2 rx \<rbrakk> \<Longrightarrow>
  well_typed (restr_env env rs_map) r_s1 v tau r_s2 rx"  
  apply (simp add: restr_env_eq)
  (*apply (rule_tac well_typed_restr_ih)
     apply (auto)
  apply (simp add: contain_env_def)
  apply (auto)
  apply (case_tac "np_restr_env env rs_map x")
   apply (auto)
  apply (simp add: np_restr_env_def)
  apply (simp add: restr_env_def)
  apply (auto)
  apply (case_tac "lookup_mem rs_map x = None \<and> non_prim_entry env x")
   apply (auto)
  apply (simp add: non_prim_env_def)
  apply (simp add: non_prim_entry_def)
  apply (erule_tac x="x" in allE)
  apply (auto)  *)
  done
  
lemma well_typed_list_restr: "\<lbrakk> (*scope_res_map rs_map; non_prim_env env;*) sub_res_map s rs_map;
  sub_env s env; well_typed_list env rs_list el n tau \<rbrakk> \<Longrightarrow>
  well_typed_list (restr_env env rs_map) rs_list el n tau"
  apply (induct el arbitrary: n)
   apply (auto)
  apply (rule_tac well_typed_restr)
    apply (auto)(*
  apply (rule_tac self_scope_use_env)
  apply (simp)*)
  done
    
definition rs_free_vars where
  "rs_free_vars rs_map e = (\<forall> x. lookup_mem rs_map x = None \<longrightarrow> x \<notin> free_vars e)"

lemma rem_add_restr_env: "rem_env (restr_env s rs_map) x = restr_env (rem_env s x) (add_mem rs_map x r_c)"  
  apply (case_tac "\<forall> y. rem_env (restr_env s rs_map) x y = restr_env (rem_env s x) (add_mem rs_map x r_c) y")
   apply (auto)
  apply (simp add: rem_env_def)
  apply (simp add: add_mem_def)
  apply (simp add: restr_env_def)
  apply (case_tac "x = y")
   apply (auto)
  apply (simp add: restr_env_def)
  apply (case_tac "lookup_mem rs_map y")
   apply (auto)
  done
    
    (* a lemma that states that every free variable of e appears in rs_map *)
lemma well_typed_rs_free_vars: "\<lbrakk> scope_use_env rs_map r_s1; well_typed env r_s1 e tau r_s2 rx; non_prim_env env \<rbrakk> \<Longrightarrow> rs_free_vars rs_map e"
  apply (simp add: rs_free_vars_def)
  apply (auto)
  apply (case_tac "r_s1 x = NoPerm")
   apply (cut_tac ?r_s1.0="r_s1" and x="x" and e="e" in well_typed_no_npv_use)
     apply (auto)
   apply (simp add: non_prim_vars_def)
   apply (simp add: non_prim_env_def)
   apply (erule_tac x="x" in allE)
   apply (cut_tac env="env" and x="x" and e="e" in well_typed_fv_env_use)
     apply (auto)
   apply (simp add: non_prim_entry_def)
  apply (simp add: scope_use_env_def)
  done


    (*
lemma aff_value_restr: "\<lbrakk> aff_value s e; rs_free_vars (rs_map :: perm_use_env p_stack) e \<rbrakk> \<Longrightarrow> aff_value (restr_env s rs_map) e"    
  apply (induct e arbitrary: s rs_map)
       apply (auto)
    (* var case. *)
        apply (simp add: restr_env_def)
        apply (simp add: rs_free_vars_def)
        apply (erule_tac x="x1a" in allE)
        apply (auto)
    (* if cases 1 - 3. *)
       apply (simp add: rs_free_vars_def)
      apply (simp add: rs_free_vars_def)
     apply (simp add: rs_free_vars_def)
    (* lam case. *)
    apply (case_tac "\<not> rs_free_vars (add_mem rs_map x1a empty_use_env) e")
     apply (simp add: rs_free_vars_def)
     apply (auto)
     apply (erule_tac x="x" in allE)
     apply (simp add: add_mem_def)
     apply (case_tac "x = x1a")
      apply (auto)
    apply (cut_tac s="s" and rs_map="rs_map" and x="x1a" and r_c="empty_use_env" in rem_add_restr_env)
    apply (auto)
    (* app cases 1 + 2. *)
   apply (simp add: rs_free_vars_def)
  apply (simp add: rs_free_vars_def)
  done
    
lemma neg_aff_value_restr: "\<lbrakk> \<not> aff_value s e; rs_free_vars (rs_map :: perm_use_env p_stack) e \<rbrakk> \<Longrightarrow> \<not> aff_value (restr_env s rs_map) e"    
  apply (induct e arbitrary: s rs_map)
       apply (auto)
    (* var case. *)
        apply (simp add: restr_env_def)
        apply (simp add: rs_free_vars_def)
        apply (erule_tac x="x1a" in allE)
        apply (auto)
    (* if cases 1 - 3. *)
       apply (simp add: rs_free_vars_def)
      apply (simp add: rs_free_vars_def)
     apply (simp add: rs_free_vars_def)
    (* lam case. *)
    apply (case_tac "\<not> rs_free_vars (add_mem rs_map x1a empty_use_env) e")
     apply (simp add: rs_free_vars_def)
     apply (auto)
     apply (erule_tac x="x" in allE)
     apply (simp add: add_mem_def)
     apply (case_tac "x = x1a")
      apply (auto)
    apply (cut_tac s="s" and rs_map="rs_map" and x="x1a" and r_c="empty_use_env" in rem_add_restr_env)
    apply (auto)
    (* app cases 1 + 2. *)
   apply (simp add: rs_free_vars_def)
  apply (simp add: rs_free_vars_def)
  done
    
lemma aff_pair_restr: "\<lbrakk> aff_pair s v1 v2 a; rs_free_vars (rs_map :: perm_use_env p_stack) v1; rs_free_vars rs_map v2 \<rbrakk> \<Longrightarrow> aff_pair (restr_env s rs_map) v1 v2 a"
  apply (simp add: aff_pair_def)
  apply (auto)
     apply (cut_tac s="s" and rs_map="rs_map" and e="v1" in neg_aff_value_restr)
       apply (auto)
    apply (cut_tac s="s" and rs_map="rs_map" and e="v2" in neg_aff_value_restr)
      apply (auto)
   apply (cut_tac s="s" and rs_map="rs_map" and e="v1" in aff_value_restr)
     apply (auto)
  apply (cut_tac s="s" and rs_map="rs_map" and e="v2" in aff_value_restr)
    apply (auto)
  done
    *)
lemma well_typed_mv_restr: "\<lbrakk> (*scope_res_map rs_map; non_prim_env env;*)
  sub_res_map s rs_map; sub_env s env;  well_typed_mem_value s env (lookup_res rs_map x) tau v \<rbrakk> \<Longrightarrow>
  well_typed_mem_value (restr_env s rs_map) (restr_env env rs_map) (lookup_res rs_map x) tau v"    
  apply (case_tac v)
  apply (auto)
  apply (rule_tac x="rs_list" in exI)
  apply (auto)
   apply (rule_tac well_typed_list_restr)
    apply (auto)(*
  apply (rule_tac x="rx1" in exI)
  apply (auto)
  apply (rule_tac x="rx2" in exI)
  apply (auto)
(*
    apply (rule_tac aff_pair_restr)
      apply (auto)
     apply (rule_tac well_typed_rs_free_vars)
      apply (auto)
    apply (rule_tac well_typed_rs_free_vars)
     apply (auto)*)
   apply (rule_tac well_typed_restr)
     apply (auto)
   apply (rule_tac self_scope_use_env)
   apply (simp)
  apply (rule_tac well_typed_restr)
    apply (auto)
  apply (rule_tac self_scope_use_env)
  apply (simp)*)
  done

definition spec_scope_use_env where
  "spec_scope_use_env rs_map rs_map' = (\<forall> y. case lookup_mem rs_map' y of None \<Rightarrow> True | Some (r_s, rs_map') \<Rightarrow> lookup_mem rs_map y = Some (r_s, rs_map'))"

lemma add_spec_scope_use_env: "\<lbrakk> spec_scope_use_env rs_map rs_map'; fresh_map_var rs_map x \<rbrakk> \<Longrightarrow> spec_scope_use_env (add_mem rs_map x r_s) rs_map'"
  apply (simp add: spec_scope_use_env_def)
  apply (auto)
  apply (case_tac "lookup_mem rs_map' y")
   apply (auto)
  apply (erule_tac x="y" in allE)
  apply (auto)
  apply (simp add: fresh_map_var_def)
  apply (simp add: add_mem_def)
  apply (auto)
  done
    
lemma self_spec_scope_use_env: "\<lbrakk> scope_res_map rs_map; lookup_mem rs_map x = Some (r_s, rs_map') \<rbrakk> \<Longrightarrow> spec_scope_use_env rs_map rs_map'"
  apply (induct rs_map)
   apply (auto)
    (* if x1 = x, rs_map' is only one level down from rs_map. any y that can be sucessfully looked-up from rs_map' is distinct from x1 by freshness,
      meaning we look it up from rs_map' *)
  apply (case_tac "x1 = x")
   apply (auto)
   apply (simp add: spec_scope_use_env_def)
   apply (auto)
   apply (simp add: scope_res_map_def)
   apply (simp add: fresh_map_var_def)
   apply (case_tac "lookup_mem rs_map' y")
    apply (auto)
    (* otherwise we have to induct *)
  apply (cut_tac rs_map="rs_map" and x="x1" and r_s="x2" in add_scope_res_map_rev)
   apply (simp add: add_mem_def)
  apply (auto)
  apply (cut_tac rs_map="rs_map" and x="x1" and rs_map'="rs_map'" in add_spec_scope_use_env)
    apply (simp)
   apply (simp add: scope_res_map_def)
  apply (simp add: add_mem_def)
  done    
    (*
lemma well_typed_restr_state: "\<lbrakk> well_typed_state s env rs_map; lookup_mem rs_map x = Some (r_s, rs_map') \<rbrakk> \<Longrightarrow>
  well_typed_state (restr_env s rs_map') (restr_env env rs_map') rs_map'"
  apply (simp add: well_typed_state_def)
  apply (auto)
    apply (rule_tac restr_sub_env)
    apply (simp)
   apply (rule_tac restr_valid_res_map)
    apply (auto)
  apply (case_tac "restr_env s rs_map' xa")
   apply (auto)
  apply (case_tac "s xa = None")
   apply (simp add: restr_env_def)
   apply (case_tac "lookup_mem rs_map' xa")
    apply (auto)
  apply (case_tac "restr_env env rs_map' xa")
   apply (auto)
   apply (erule_tac x="xa" in allE)
   apply (case_tac "env xa \<noteq> None")
    apply (simp add: restr_env_def)
    apply (case_tac "lookup_mem rs_map' xa")
     apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (auto)
  apply (case_tac "env xa")
   apply (auto)
  apply (case_tac "aa \<noteq> ab")
   apply (simp add: restr_env_def)
   apply (case_tac "lookup_mem rs_map' xa")
    apply (auto)
  apply (rule_tac well_typed_mv_restr)
   apply (simp add: valid_res_map_def)
   apply (auto)
   apply (rule_tac rs_map="rs_map" and x="x" in self_scope_res_map)
    apply (auto)
  apply (simp add: restr_env_def)
  apply (case_tac "lookup_mem rs_map' xa")
   apply (auto)
  apply (simp add: lookup_res_def)
  apply (cut_tac rs_map="rs_map" and rs_map'="rs_map'" in self_spec_scope_use_env)
    apply (auto)
   apply (simp add: valid_res_map_def)
  apply (simp add: spec_scope_use_env_def)
  apply (erule_tac x="xa" in allE)
  apply (auto)
  done    *)
    
end