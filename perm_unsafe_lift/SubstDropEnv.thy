theory SubstDropEnv
  imports FlatLemma SubstExp
begin




  
    (* the issue we're having right now is that if we freely allow for r_s1 / r_s2, then in application, it's
      possible that the reqs include ownerships that they dont need, which then get removed from the final reqs.
       *)    
    
    (* the reasoning behind this lemma is that if tau is unlim, then we only require unlim reqs. *)(*
lemma wt_sexp_drop_req: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx'; req_type tau \<noteq> Aff; (*\<not> aff_fun_ty tau;*) is_sexp e \<rbrakk> \<Longrightarrow>
    well_typed env r_s1 e tau r_s2 (drop_use_env rx')"      
  apply (induction e arbitrary: env tau r_s1 r_s2 rx')
        apply (auto)
    (* const + op case *)
       apply (rule_tac drop_leq_use_env)
       apply (auto)
      apply (rule_tac drop_leq_use_env)
      apply (auto)
    (* var case *)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
      apply (rule_tac drop_leq_use_env)
      apply (simp)
     apply (rule_tac rhs_drop_leq_use_env)
      apply (rule_tac weak_diff_use_env)
      apply (simp add: weak_use_env_def)
      apply (simp add: ereq_use_env_def)
      apply (simp add: end_req_perm_def)
      apply (simp add: one_use_env_def)
      apply (case_tac tau)
            apply (auto)
    (* pair case *)
    apply (rule_tac x="rx" in exI)
    apply (rule_tac x="rx1" in exI)
    apply (auto)
    apply (rule_tac x="rx2" in exI)
    apply (auto)
    apply (rule_tac x="r_ex" in exI)
    apply (auto)
     apply (rule_tac drop_leq_use_env)
     apply (simp)
    apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac weak_diff_use_env)
    apply (simp add: aff_use_env_def)
     apply (case_tac "max_aff (req_type t1) (req_type t2)")
       apply (auto)
     apply (simp add: weak_use_env_def)
    apply (simp add: null_use_env_def)
    (* lam case *)
   apply (rule_tac x="rx" in exI)
   apply (auto)
   apply (rule_tac x="r_ex" in exI)
   apply (auto)
    apply (rule_tac drop_leq_use_env)
    apply (simp)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac weak_diff_use_env)
    apply (auto)
   apply (simp add: aff_use_env_def)
   apply (case_tac a)
     apply (auto)
   apply (simp add: null_use_env_def)
   apply (simp add: weak_use_env_def)
    (* app case. e1 *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="r_s2a" in exI)
  apply (rule_tac x="drop_use_env rx1" in exI)
  apply (auto)
   apply (case_tac e1)
        apply (auto)
   apply (rule_tac drop_leq_use_env)
    apply (simp)
    (* app case. e2, lambda unrolling *)
  apply (rule_tac x="drop_use_env rx2" in exI)
  apply (rule_tac x="r_s3" in exI)
  apply (auto)
   apply (cut_tac ?e1.0="e1" and ?e2.0="e2" in e2_sexp)
    apply (auto)
   apply (case_tac "\<not> unlim t1")
    apply (case_tac e1)
         apply (auto)
   apply (case_tac x1)
               apply (auto)
    apply (simp add: pure_fun_def)
   apply (simp add: unlim_def)
    (* - final manipulation *)
  apply (rule_tac x="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in exI)
  apply (auto)
       apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
        apply (rule_tac dist_diff_leq_use_env_gen)
         apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac self_drop_leq_use_env)
          apply (rule_tac comp_leq_use_env2)
          apply (rule_tac dist_lift_leq_use_env)
          apply (rule_tac self_drop_leq_use_env)
         apply (rule_tac id_leq_use_env)
        apply (simp)
       apply (simp add: drop_use_env_def)
       apply (case_tac r)
         apply (auto)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac comp_leq_use_env1)
       apply (rule_tac self_drop_leq_use_env)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac r_s="rx1" in disj_leq_use_env1)
      apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
       apply (simp)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac self_drop_leq_use_env)
    apply (rule_tac drop_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  apply (simp add: app_req_def)
  apply (case_tac "req_type tau = Prim")
   apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac r_sb="drop_use_env (diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" in trans_leq_use_env)
   apply (rule_tac dist_drop_leq_use_env)
   apply (simp)
  apply (cut_tac r_s="comp_use_env rx1 rx2" and r_ex="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in diff_drop_use_env)
  apply (simp)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac dist_drop_leq_use_env)
    apply (rule_tac self_comp_leq_use_env1)
   apply (rule_tac dist_drop_leq_use_env)
   apply (rule_tac self_comp_leq_use_env2)
  apply (rule_tac self_comp_leq_use_env2)
  done   *) 

(*
lemma wt_sexp_drop_all: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; req_type tau \<noteq> Aff; is_sexp e \<rbrakk> \<Longrightarrow> well_typed env (drop_use_env r_s1) e tau (drop_use_env r_s1) (drop_use_env rx)"    
  apply (induct e arbitrary: env r_s1 r_s2 tau rx)
        apply (auto)
    (* const + op cases *)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_drop_leq_use_env)
         apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
          apply (simp_all)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
        apply (simp_all)
    (* var case p1. *)
      apply (rule_tac ereq_leq_use_envx)
      apply (cut_tac r_x="ereq_use_env x1a tau" and r_s="r_s1" and x="x1a" in spec_leq_perm)
       apply (simp)
      apply (simp add: ereq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: drop_use_env_def)
      apply (simp add: end_req_perm_def)
      apply (case_tac "req_type tau")
        apply (auto)
    (* var case p2. *)
     apply (rule_tac x="empty_use_env" in exI)
     apply (auto)
        apply (rule_tac rhs_weak_leq_use_env)
         apply (rule_tac dist_weak_comp_use_env)
          apply (simp add: weak_use_env_def)
          apply (simp add: ereq_use_env_def)
          apply (simp add: one_use_env_def)
          apply (simp add: end_req_perm_def)
          apply (case_tac "req_type tau")
            apply (auto)
         apply (simp add: weak_use_env_def)
         apply (simp add: empty_use_env_def)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
        apply (simp_all)
       apply (rule_tac r_sb="diff_use_env r_s1 (comp_use_env (ereq_use_env x1a tau) r_ex)" in trans_leq_use_env)
        apply (rule_tac self_diff_leq_use_env)
       apply (simp)
      apply (rule_tac leq_empty_use_env)*)

    
    (*
lemma wt_sexp_drop_all: "\<lbrakk> well_typed env rx e tau rx rx'; req_type tau \<noteq> Aff; is_sexp e \<rbrakk> \<Longrightarrow> well_typed env (drop_use_env rx) e tau (drop_use_env rx) (drop_use_env rx')"    
  apply (induct e arbitrary: env tau rx rx')
        apply (auto)
    (* const + op cases *)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_drop_leq_use_env)
         apply (simp)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (simp)
    (* var case p1 *)
      apply (simp add: ereq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: leq_use_env_def)
      apply (simp add: drop_use_env_def)
      apply (auto)
       apply (simp add: end_req_perm_def)
       apply (case_tac "req_type tau")
         apply (auto)
      apply (erule_tac x="x1a" in allE)
      apply (simp)
    (* var case p2 *)
     apply (cut_tac r_s="rx" and r_x="comp_use_env (ereq_use_env x1a tau) r_ex" in wtsdr_weak_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (auto)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
        apply (rule_tac rhs_weak_leq_use_env)
         apply (simp)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (simp)
      apply (rule_tac rhs_drop_leq_use_env)
       apply (rule_tac r_sa="ereq_use_env x1a tau" in weak_comp_use_env2)
       apply (auto)
     apply (rule_tac rhs_drop_leq_use_env)
      apply (rule_tac weak_diff_use_env)
      apply (rule_tac r_sb="r_ex" in weak_comp_use_env1)
      apply (auto)
    (* pair case *)
    apply (case_tac "\<not> (req_type t1 \<noteq> Aff \<and> req_type t2 \<noteq> Aff)")
     apply (auto)
     apply (case_tac "req_type t1")
       apply (auto)
    apply (cut_tac r_s="rx" and r_x="r_ex" in wtsdr_weak_use_env)
      apply (auto)
    apply (rule_tac x="drop_use_env rxa" in exI)
    apply (rule_tac x="drop_use_env rx1" in exI)
    apply (auto)
     apply (rule_tac x="drop_use_env (comp_use_env r_xa (infl_use_env rx1 r_sa))" in exI)
     apply (rule_tac x="drop_use_env rx1" in exI)
     apply (cut_tac e="e1" in value_is_sexp)
      apply (auto)
     apply (cut_tac env="env" and ?r_s1.0="rx1" and e="e1" and ?r_s2.0="r_sa" and rx="r_xa" in infl_full_sexp_wp)
       apply (auto)
    apply (rule_tac x="drop_use_env rx2" in exI)
    apply (auto)
         apply (rule_tac x="drop_use_env (comp_use_env r_xb (infl_use_env rx2 r_sb))" in exI)
         apply (rule_tac x="drop_use_env rx2" in exI)
         apply (cut_tac e="e2" in value_is_sexp)
          apply (auto)
         apply (cut_tac env="env" and ?r_s1.0="rx2" and e="e2" and ?r_s2.0="r_sb" and rx="r_xb" in infl_full_sexp_wp)
           apply (auto)
        apply (rule_tac dist_drop_leq_use_env)
        apply (simp)
       apply (rule_tac dist_drop_leq_use_env)
       apply (simp)
      apply (rule_tac dist_drop_leq_use_env)
      apply (simp)
     apply (rule_tac r_s="lift_use_env rx1 r" in disj_leq_use_env1)
      apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
       apply (simp)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac dist_lift_leq_use_env)
     apply (rule_tac self_drop_leq_use_env)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (simp add: weak_use_env_def)
        apply (simp add: empty_use_env_def)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac dist_drop_leq_use_env)
      apply (simp)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac r_sb="drop_use_env (diff_use_env rxa r_ex)" in trans_leq_use_env)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac dist_drop_leq_use_env)
    apply (rule_tac rhs_weak_leq_use_env)
     apply (simp)
    apply (rule_tac id_leq_use_env)
    (* lam case *)
   apply (simp add: aff_use_env_def)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
    apply (rule_tac rhs_drop_leq_use_env)
     apply (auto)
    apply (case_tac a)
      apply (auto)
    apply (simp add: weak_use_env_def)
    apply (simp add: null_use_env_def)
   apply (cut_tac r_s="rx" and r_x="r_ex" in wtsdr_weak_use_env)
     apply (auto)
   apply (rule_tac x="r_ex" in exI)
   apply (auto)
      apply (rule_tac rhs_weak_leq_use_env)
       apply (simp)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac rhs_drop_leq_use_env)
     apply (auto)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac weak_diff_use_env)
    apply (auto)
   apply (case_tac a)
     apply (auto)
   apply (simp add: weak_use_env_def)
   apply (simp add: null_use_env_def)
    (* app case. e1 *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="drop_use_env rx" in exI)
  apply (rule_tac x="empty_use_env" in exI)
  (*apply (rule_tac x="drop_use_env rx1" in exI)*)
  apply (auto)
   apply (case_tac e1)
        apply (auto)
    apply (rule_tac id_leq_use_env)(*
    apply (rule_tac dist_drop_leq_use_env)
    apply (simp)*)
   apply (rule_tac leq_empty_use_env)(*
   apply (rule_tac dist_drop_leq_use_env)
   apply (simp)*)
    (* app case. e2, lambda unrolling *)
  apply (rule_tac x="drop_use_env rx2" in exI)
  apply (rule_tac x="drop_use_env rx" in exI)
  apply (auto)
   apply (cut_tac env="env" and r_c="rx" and ?r_s1.0="r_s2" and ?r_s2.0="rx" and e="e2" and tau="t1" and rx="rx2" in well_typed_incr_start_perm)
     apply (rule_tac r_c="r_s3" in well_typed_decr_end_perm)
       apply (simp)
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac self_diff_leq_use_env)
      apply (simp)
     apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
      apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* - prove that e2 is an s-expression *)
   apply (case_tac "\<not> is_sexp e2")
    apply (cut_tac ?e1.0="e1" and ?e2.0="e2" in e2_sexp)
     apply (simp_all)
    (* - prove that t1 is unlim *)
   apply (case_tac "\<not> req_type t1 \<noteq> Aff")
    apply (case_tac e1)
         apply (auto)
   apply (case_tac x1)
                apply (auto)
   apply (simp add: pure_fun_def)
    (* app case. tau primitive case (only happens for fixed point w/ primitive fun) *)
  apply (simp add: app_req_def)
  apply (case_tac "req_type tau = Prim")
   apply (auto)
   apply (case_tac e1)
        apply (auto)
   apply (case_tac x1)
               apply (auto)
   apply (simp add: pure_fun_def)
   apply (auto)
   apply (case_tac t)
         apply (auto)
   apply (case_tac "\<not> weak_use_env empty_use_env")
    apply (simp add: weak_use_env_def)
    apply (simp add: empty_use_env_def)
   apply (rule_tac x="empty_use_env" in exI)
   apply (auto)
         apply (rule_tac rhs_weak_leq_use_env)
          apply (rule_tac dist_weak_comp_use_env)
           apply (rule_tac dist_weak_comp_use_env)
            apply (auto)
          apply (rule_tac drop_weak_use_env)
         apply (rule_tac id_leq_use_env)
        apply (simp add: drop_use_env_def)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac leq_empty_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
       apply (rule_tac well_typed_perm_leqx)
       apply (auto)
      apply (rule_tac disj_empty_use_env2)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac leq_empty_use_env)
   apply (rule_tac leq_empty_use_env)
    (* non prim case. *)
    (* - prove weakness of rx1 + rx2 + r_ex *)
  apply (cut_tac r_s="r_s3" and r_x="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in wtsdr_weak_use_env)
    apply (rule_tac r_sb="rx" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac dist_comp_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="rx" in trans_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (simp_all)
    (* - r not ownership *)
  apply (case_tac "r = OwnPerm")
   apply (case_tac e1)
        apply (auto)
   apply (case_tac x1)
               apply (auto)
   apply (simp add: pure_fun_def)
    (* - final manipulation *)
  apply (rule_tac x="r_ex" in exI)
  apply (auto)
        apply (rule_tac rhs_weak_leq_use_env)
         apply (rule_tac r_s="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in leq_weak_use_env)
          apply (simp)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac leq_empty_use_env)
          apply (rule_tac comp_leq_use_env2)
          apply (rule_tac dist_lift_leq_use_env)
          apply (rule_tac self_drop_leq_use_env)
         apply (rule_tac self_comp_leq_use_env2)
        apply (rule_tac id_leq_use_env)
       apply (simp add: drop_use_env_def)
       apply (case_tac r)
         apply (auto)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac leq_empty_use_env)
      apply (case_tac r)
        apply (auto)
      apply (rule_tac dist_drop_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac disj_empty_use_env2)
    apply (rule_tac dist_drop_leq_use_env)
    apply (simp)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac r_sa="comp_use_env rx1 (lift_use_env rx2 r)" in weak_comp_use_env2)
    apply (auto)
  apply (rule_tac r_sb="drop_use_env (diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" in trans_leq_use_env)
   apply (rule_tac dist_drop_leq_use_env)
   apply (auto)
  apply (rule_tac rhs_drop_leq_use_env)
   apply (rule_tac weak_diff_use_env)
   apply (rule_tac dist_weak_comp_use_env)
    apply (simp add: weak_use_env_def)
    apply (simp add: empty_use_env_def)
   apply (rule_tac drop_weak_use_env)
  apply (rule_tac rhs_weak_leq_use_env)
   apply (simp)
  apply (rule_tac diff_leq_use_env)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (rule_tac self_drop_leq_use_env)
  done*)
    
    (*
lemma wt_sexp_drop_req: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; req_type tau \<noteq> Aff; (*\<not> aff_fun_ty tau;*) is_sexp e \<rbrakk> \<Longrightarrow>
    well_typed env r_s1 e tau r_s2 (drop_use_env rx)"
  apply (induct e arbitrary: env tau r_s1 r_s2 rx)
        apply (auto)
    (* const + op case *)
       apply (rule_tac drop_leq_use_env)
       apply (simp)
      apply (rule_tac drop_leq_use_env)
      apply (simp)
    (* var case *)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
      apply (rule_tac drop_leq_use_env)
      apply (simp)
     apply (rule_tac rhs_drop_leq_use_env)
      apply (rule_tac weak_diff_use_env)
      apply (simp add: weak_use_env_def)
      apply (simp add: ereq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: end_req_perm_def)
      apply (case_tac "req_type tau")
        apply (auto)
    (* pair case *)
    apply (rule_tac x="drop_use_env rxa" in exI)
    (* - e1. the idea is that we should be able to drop the perms.  *)
    apply (rule_tac x="drop_use_env rx1" in exI)
    apply (auto)
    apply (rule_tac x="drop_use_env rx2" in exI)
    apply (auto)
    *)
    
lemma wt_sexp_drop_req: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; req_type tau \<noteq> Aff; (*\<not> aff_fun_ty tau;*) is_sexp e \<rbrakk> \<Longrightarrow>
    well_typed env r_s1 e tau r_s2 (drop_use_env rx)"
  apply (rule_tac ?r_s2.0="diff_use_env r_s1 (infl_use_env r_s1 r_s2)" and
      rx="diff_use_env (drop_use_env (comp_use_env rx (infl_use_env r_s1 r_s2))) (infl_use_env r_s1 r_s2)" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac r_s="drop_use_env r_s1" in well_typed_incr_simul_perm)
       apply (rule_tac self_drop_leq_use_env)
      apply (rule_tac wt_sexp_drop_all)
        apply (rule_tac infl_full_sexp_wp)
         apply (auto)
     apply (rule_tac self_infl_leq_use_env)
    apply (rule_tac disj_diff_leq_use_env)
     apply (rule_tac comm_disj_use_env)
     apply (rule_tac infl_disj_use_env)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac drop_leq_use_env)
   apply (rule_tac well_typed_perm_leqx)
   apply (auto)
  apply (cut_tac r_sa="rx" and r_sb="infl_use_env r_s1 r_s2" in dist_drop_comp_use_env)
  apply (auto)
  apply (rule_tac lhs_dist_dcl_use_env)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac self_diff_leq_use_env)
  apply (rule_tac r_sb="diff_use_env (infl_use_env r_s1 r_s2) (infl_use_env r_s1 r_s2)" in trans_leq_use_env)
   apply (rule_tac diff_infl_leq_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac self_drop_leq_use_env)
  done
    
fun drop_use_env_ex where
  "drop_use_env_ex r_s OwnPerm = r_s"
| "drop_use_env_ex r_s r = drop_use_env r_s"

definition tau_drop_req where
  "tau_drop_req r tau = (if r = OwnPerm then True else req_type tau \<noteq> Aff)"
    
lemma wt_sexp_drop_all_ex: "\<lbrakk> well_typed env rx e tau rx rx; tau_drop_req r tau; is_sexp e \<rbrakk> \<Longrightarrow> well_typed env (drop_use_env_ex rx r) e tau (drop_use_env_ex rx r) (drop_use_env_ex rx r)" 
  apply (simp add: tau_drop_req_def)
  apply (case_tac r)
    apply (auto)
   apply (rule_tac wt_sexp_drop_all)
     apply (auto)
  apply (rule_tac wt_sexp_drop_all)
    apply (auto)
  done
    
end