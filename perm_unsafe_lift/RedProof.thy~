theory RedProof
  imports SubProof WTState InflLemma
begin
(*
lemma sares_lam_helper: "\<lbrakk> well_typed env r_s1 e2 tau (diff_use_env (comp_use_env r_s3 (cut_use_env r_exa)) (comp_use_env rxa (lift_use_env rx2 r)))
      (diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))); non_prim_env env \<rbrakk> \<Longrightarrow>
  well_typed env r_s1 e2 tau (diff_use_env (comp_use_env r_s3 (cut_use_env r_exa)) (comp_use_env rxa (lift_use_env rx2 r))) (app_req rxa rx2 r tau empty_use_env)"
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac rx="diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))" in prim_type_no_req)
     apply (auto)
  apply (cut_tac r="comp_use_env rxa (lift_use_env rx2 r)" in comp_empty_use_env2)
  apply (auto)
  done*)

lemma sares_lam_helper: "\<lbrakk> well_typed env r_s1 e2 tau (diff_use_env (comp_use_env r_s3 r_exa) (comp_use_env rxa (lift_use_env rx2 r)))
      (diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))); non_prim_env env \<rbrakk> \<Longrightarrow>
  well_typed env r_s1 e2 tau (diff_use_env (comp_use_env r_s3 r_exa) (comp_use_env rxa (lift_use_env rx2 r))) (app_req rxa rx2 r tau empty_use_env)"
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac rx="diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))" in prim_type_no_req)
     apply (auto)
  apply (cut_tac r="comp_use_env rxa (lift_use_env rx2 r)" in comp_empty_use_env2)
  apply (auto)
  done  (*
  
lemma sares_intro_leq_use_env: "\<lbrakk> cs \<subseteq> cs' \<rbrakk> \<Longrightarrow> leq_use_env (intro_use_env empty_use_env cs) (intro_use_env empty_use_env cs')"
  apply (simp add: leq_use_env_def)
  apply (simp add: intro_use_env_def)
  apply (simp add: empty_use_env_def)
  apply (auto)
  done

lemma sares_intro_disj_use_env: "disj_use_env (intro_use_env empty_use_env cs) (intro_use_env empty_use_env cs')"    
  apply (simp add: disj_use_env_def)
  apply (simp add: intro_use_env_def)
  apply (simp add: mini_disj_use_env_def)
  apply (simp add: empty_use_env_def)
  done*)
(*
lemma sares_well_typed: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; is_value e; sub_env s env \<rbrakk> \<Longrightarrow>
  well_typed env (intro_use_env empty_use_env (name_set s e)) e tau (intro_use_env empty_use_env (name_set s e))
            (intro_use_env empty_use_env (name_set s e))"
  apply (case_tac "name_set s e = {}")
   apply (auto)
   apply (case_tac e)
        apply (auto)
    
  apply (case_tac "s x = None")
   apply (case_tac "env x \<noteq> None")
    apply (simp add: sub_env_def)
  apply (auto)
     apply (rule_tac req_leq_use_envx)
     apply (simp add: start_req_perm_def)
     apply (auto)
      apply (simp add: aff_fun_ty_def)
      apply (case_tac tau)
            apply (auto)
     apply (simp add: intro_use_env_def)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (rule_tac dist_weak_comp_use_env)
         apply (rule_tac weak_req_use_env)
         apply (case_tac tau)
               apply (auto)
        apply (simp add: weak_use_env_def)
        apply (simp add: empty_use_env_def)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac req_leq_use_envx)
    apply (simp add: start_req_perm_def)
    apply (auto)
     apply (simp add: aff_fun_ty_def)
     apply (case_tac tau)
           apply (auto)
    apply (simp add: intro_use_env_def)
   apply (case_tac y)
    apply (auto)
  apply (case_tac y)
   apply (auto)
  done
    *)
    
    
lemma lease_mini_disj_use_env: "\<lbrakk> mini_disj_use_env r_s (diff_use_env r_x r_ex); mini_disj_use_env r_ex r_s \<rbrakk> \<Longrightarrow> mini_disj_use_env r_s r_x"    
  apply (simp add: mini_disj_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: minus_use_env_def)
  apply (simp add: neg_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (case_tac "r_ex x")
    apply (auto)
   apply (case_tac "r_x x")
     apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done
   
lemma lease_disj_use_env1: "\<lbrakk> disj_use_env r_s (diff_use_env r_x r_ex); mini_disj_use_env r_ex r_s \<rbrakk> \<Longrightarrow> disj_use_env r_s r_x"    
  apply (simp add: disj_use_env_def)
  apply (auto)
   apply (rule_tac lease_mini_disj_use_env)
    apply (auto)
    (* we expect a similar formulation to exist using this logic
      rx2a | rx2 + [infl r_s2a - r_s3], rx2a |> rx2 + [infl r_s2a - r_s3], rx2a |> r_s3 - EX, EX |> r_s3 - EX
      rx2 + [infl r_s2a - r_s3] |> rx2a - EX
          apply (rule_tac r_s="diff_use_env r_s r_ex" in mini_disj_leq_use_env2)
    *)
  apply (simp add: mini_disj_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: minus_use_env_def)
  apply (simp add: neg_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (auto)
   apply (case_tac "r_ex x")
     apply (auto)
  apply (case_tac "r_ex x")
    apply (auto)
  done
 
lemma lease_disj_use_env2: "\<lbrakk> disj_use_env (diff_use_env r_x r_ex) r_s; mini_disj_use_env r_ex r_s \<rbrakk> \<Longrightarrow> disj_use_env r_x r_s"
  apply (rule_tac comm_disj_use_env)
  apply (rule_tac r_ex="r_ex" in lease_disj_use_env1)
   apply (rule_tac comm_disj_use_env)
   apply (auto)
  done
    (*
lemma well_typed_norm_env: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx \<rbrakk> \<Longrightarrow>
  well_typed env (norm_use_env r_s1 r_ex) e tau (norm_use_env r_s2 r_ex) (norm_use_env rx r_ex)"    
  apply (induct e arbitrary: env r_s1 r_s2 tau rx)
  *)
    
definition res_use_env where
  "res_use_env rs_map = (\<lambda>  x. if lookup_mem rs_map x = None then NoPerm else OwnPerm)"
    
lemma norm_res_leq_use_env: "\<lbrakk> well_typed_state s env rs_map; valid_use_env s rs_map r_s \<rbrakk> \<Longrightarrow> leq_use_env r_s (res_use_env rs_map)"
  apply (simp add: leq_use_env_def)
  apply (simp add: res_use_env_def)
  apply (auto)
  apply (simp add: valid_use_env_def)
  apply (simp add: well_typed_state_def)
  apply (simp add: valid_res_map_def)
  apply (simp add: sub_res_map_def)
  apply (simp add: sub_use_env_def)
  done
    
lemma norm_res_use_env: "\<lbrakk> leq_use_env r_s (res_use_env rs_map) \<rbrakk> \<Longrightarrow> norm_use_env r_s (res_use_env rs_map) = r_s"  
  apply (case_tac "\<forall> x. norm_use_env r_s (res_use_env rs_map) x = r_s x")
   apply (auto)
  apply (simp add: norm_use_env_def)
  apply (simp add: res_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (erule_tac x="x" in allE)
  apply (case_tac "lookup_mem rs_map x")
   apply (auto)
  apply (case_tac "r_s x")
    apply (auto)
  done
    
lemma well_typed_incr_simul_perm: "\<lbrakk> leq_use_env r_s r_c; well_typed env r_s e tau r_s rx \<rbrakk> \<Longrightarrow> well_typed env r_c e tau r_c rx"
  apply (rule_tac t="r_c" and s="comp_use_env r_s (diff_use_env r_c r_s)" in subst)
   apply (rule_tac msum_diff_comp_use_env)
   apply (simp)
  apply (rule_tac well_typed_comp_perms_gen)
   apply (simp)
  apply (rule_tac mini_disj_diff_use_env)
  done
    
lemma norm_scope_use_env: "scope_use_env rs_map (norm_use_env r_s (res_use_env rs_map))"    
  apply (simp add: scope_use_env_def)
  apply (simp add: norm_use_env_def)
  apply (simp add: res_use_env_def)
  apply (auto)
  done
  
lemma safe_app_red_exp_strict: "\<lbrakk> well_typed env r_s1 e1 tau r_s2 rx; well_typed_state s1 env rs_map; valid_use_env s1 rs_map r_s1;
  app_red_exp (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> (\<exists> tau' rs_map'.
  well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e2 tau r_s2 rx \<and>
  (*red_env env ax env' \<and> *)well_typed_state s2 (red_env env tau' ax) rs_map' \<and>
  valid_use_env s2 rs_map' (red_use_env r_s1 ax))"
  apply (case_tac e1)
       apply (auto)
   apply (case_tac x41)
        apply (auto)
   apply (case_tac x1)
      apply (auto)
   apply (case_tac x3)
    apply (auto)
    (* if case 1 *)
    apply (case_tac ax)
      apply (auto)
    apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
     apply (auto)
    apply (rule_tac rx="rx1" in well_typed_incr_req) 
      apply (simp)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
    (* if case 2 *)
   apply (case_tac ax)
    apply (auto)
   apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
    apply (auto)
  apply (rule_tac rx="rx2" in well_typed_incr_req)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
   apply (rule_tac well_typed_perm_leqx)
   apply (auto)
    (* app unrolling *)
  apply (case_tac x61)
       apply (auto)
    (* fix const *)
     apply (case_tac "x1 = FixConst")
      apply (auto)
      apply (case_tac x62)
           apply (auto)
      apply (case_tac ax)
        apply (auto)
      apply (simp add: pure_fun_def)
      apply (auto)
    (* e2 = x52 (Fix (\<lambda> x51. x52)). We can type the external app as: <<r_s1>> x52 <<r_s2a, rx1>> (Fix (\<lambda> x51. x52)) <<r_s3, rx2>>
      We can type the internal app as: <<r_s2a>> Fix <<r_s2a, {}>> (\<lambda> x51. x52) <<r_s2a, rxa>>
    *)
      apply (rule_tac ?r_s2.0="diff_use_env (diff_use_env r_s2a (comp_use_env rxa (lift_use_env rxa UsePerm))) (comp_use_env r_exa r_ex)" and
        rx="diff_use_env (diff_use_env (comp_use_env rxa rxa) (comp_use_env rxa (lift_use_env rxa UsePerm))) (comp_use_env r_exa r_ex)" in well_typed_simul_end_perm)
         apply (rule_tac well_typed_diff_end_perm)
          apply (rule_tac t="tau" and ?rx1.0="rxa" and r_s'="r_s'" and r_end="r_end" and ?e1.0="x52" and x="x51" and
          ?r_s2.0="r_s2a" and ?r_s3.0="r_s2a" and e'="AppExp (ConstExp FixConst) (LamExp x51 x52)" in safe_subst_type_preserve_x)
                   apply (auto)
             apply (rule_tac x="FunTy tau tau UsePerm NoAff" in exI)
             apply (rule_tac x="UsePerm" in exI)
             apply (auto)
              apply (simp add: pure_fun_def)
             apply (rule_tac x="r_s2a" in exI)
             apply (auto)
              apply (rule_tac id_leq_use_env)
             apply (rule_tac x="empty_use_env" in exI)
             apply (auto)
              apply (rule_tac leq_empty_use_env)
             apply (case_tac "\<not> weak_use_env empty_use_env")
              apply (simp add: weak_use_env_def)
              apply (simp add: empty_use_env_def)
             apply (rule_tac x="rxa" in exI)
             apply (rule_tac x="r_s2a" in exI)
             apply (auto)
              apply (rule_tac x="rxa" in exI)
              apply (auto)
              apply (rule_tac x="empty_use_env" in exI)
              apply (auto)
                apply (rule_tac rhs_weak_leq_use_env)
                 apply (auto)
                apply (rule_tac id_leq_use_env)
               apply (rule_tac leq_empty_use_env)
              apply (rule_tac self_diff_leq_use_env)
             apply (rule_tac x="empty_use_env" in exI)
             apply (auto)
                  apply (rule_tac rhs_weak_leq_use_env)
                   apply (rule_tac dist_weak_comp_use_env)
                    apply (rule_tac dist_weak_comp_use_env)
                     apply (auto)
                   apply (simp add: aff_use_env_def)
                  apply (rule_tac id_leq_use_env)
                 apply (simp add: aff_use_env_def)
                 apply (simp add: weak_use_env_def)
                apply (rule_tac dist_comp_leq_use_env)
                 apply (rule_tac leq_empty_use_env)
                apply (simp)
               apply (rule_tac disj_empty_use_env2)
              apply (rule_tac leq_empty_use_env)
             apply (simp add: app_req_def)
             apply (auto)
              apply (rule_tac leq_empty_use_env)
             apply (rule_tac diff_leq_use_env)
             apply (rule_tac dist_comp_leq_use_env)
              apply (rule_tac leq_empty_use_env)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
             apply (auto)
           apply (rule_tac dist_comp_leq_use_env)
            apply (auto)
          apply (simp add: aff_use_env_def)
          apply (simp add: weak_use_env_def)
         apply (simp add: aff_use_env_def)
         apply (simp add: weak_use_env_def)
         apply (simp add: disj_use_env_def)
         apply (simp add: mini_disj_use_env_def)
    (* diff correctness *)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
          apply (auto)
    (* prove bound shifts were valid. to show that r_s2 (the only end perm bound) is lower than r_s2a - rxa (our proposed bound),
        we use the fact that r_s2 \<le> r_s3 - rx2, and whatever is not removed by rx2 was already removed by r_exa from r_s2a.  *)
       apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
        apply (rule_tac r_sb="diff_use_env r_s2a (comp_use_env (diff_use_env rxa r_exa) (comp_use_env r_exa r_ex))" in trans_leq_use_env)
         apply (rule_tac rhs_fold_dcl_use_env)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (cut_tac r_ex="diff_use_env rxa r_exa" and r_s="r_exa" and r_x="r_ex" in assoc_comp_use_env)
          apply (simp)
          apply (rule_tac comp_leq_use_env1)
          apply (cut_tac r_ex="rxa" and r_x="r_exa" in sum_comp_diff_use_env)
          apply (auto)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac self_comp_leq_use_env1)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac rhs_unroll_dcl_use_env)
       apply (rule_tac unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac rhs_fold_dcl_use_env)
       apply (rule_tac rhs_flip_use_env)
       apply (rule_tac rhs_unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (simp)
       apply (rule_tac comp_leq_use_env2)
       apply (simp)
    (* to show that rx \<ge> rxa - (rxa + r_exa + r_ex) (our proposed bound). we note that rxa - r_exa \<le> rx2.
        rx \<ge> rx2 - (rx1 + rx2 + r_ex). rx1 is disjoint, rx2 is weak, r_ex is included in our bound *)
      apply (simp add: app_req_def)
      apply (case_tac tau)
            apply (auto)
      apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac rhs_dist_dcl_use_env)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac unroll_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac rhs_unroll_dcl_use_env)
      apply (rule_tac r_sb="rx2" in trans_leq_use_env)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (simp add: weak_use_env_def)
       apply (rule_tac disj_diff_leq_use_env)
        apply (simp)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac lhs_fold_dcl_use_env)
      apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac dist_diff_leq_use_env_gen)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac self_comp_leq_use_env2)(*
    (* - next we prove that the state doesn't change, and as a result is still valid *)
     apply (case_tac "s1 \<noteq> s2")
      apply (case_tac "x62")
            apply (auto)
    (* - lastly the safe env pledge *)
     apply (case_tac x62)
                   apply (auto)*)
    (* remaining const cases (which dont exists for now). the idea is that any "destructive" uses should have had
      end perms removes to begin with, so red_use_env should be fine. *)
    apply (rule_tac ?r_s1.0="r_s1" and ?r_s2.0="r_s3" and ?rx1.0="rx1" and ?rx2.0="rx2" in safe_app_con_case)
            apply (auto)
      apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
       apply (auto)
     apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
      apply (rule_tac lhs_unroll_dcl_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (simp)
    (* op case *)
   apply (case_tac "ax \<noteq> NoAct")
     apply (auto)
     apply (case_tac x62)
          apply (auto)
    apply (rule_tac ?r_s2.0="r_s1" and rx="empty_use_env" in well_typed_simul_end_perm)
       apply (rule_tac safe_app_op_case)
        apply (auto)
     apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
      apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
       apply (auto)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac x="rs_map" in exI)
   apply (case_tac x62)
         apply (auto)
    (* lam case *)
  apply (case_tac ax)
     apply (auto)
  apply (rule_tac ?r_s2.0="diff_use_env (diff_use_env (comp_use_env r_s3 (cut_use_env r_exa)) (comp_use_env rxa (lift_use_env rx2 r))) (comp_use_env r_exa (comp_use_env r_ex rx1))" and
      rx="diff_use_env (app_req rxa rx2 r tau empty_use_env) (comp_use_env r_exa (comp_use_env r_ex rx1))" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac sares_lam_helper)
        apply (auto)
     apply (rule_tac x="x51" and t="t1" and ?rx1.0="rxa" and r="r" and ?e1.0="x52" and r_s'="r_s'" and r_end="r_end"
    and e'="x62" and ?r_s2.0="comp_use_env r_s2a (cut_use_env r_exa)" and ?r_s3.0="comp_use_env r_s3 (cut_use_env r_exa)" and ?rx2.0="rx2" in safe_subst_type_preserve_x)
                apply (auto)
           apply (case_tac x62)
                apply (auto)
        apply (rule_tac well_typed_comp_perms_gen)
         apply (auto)
        apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
         apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
          apply (rule_tac dist_diff_leq_use_env_gen)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac self_cut_leq_use_env)
         apply (simp)
        apply (rule_tac strong_cut_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
         apply (rule_tac self_diff_leq_use_env)
        apply (simp)
       apply (rule_tac cut_leq_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac st_diff_comp_leq_use_env)
       apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac comp_leq_use_env1)
        apply (simp)
       apply (rule_tac diff_cut_leq_use_env)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (rule_tac comp_leq_use_env1)
       apply (simp)
      apply (rule_tac self_comp_leq_use_env2)
    (* the last thing we have to do is show that rxa is disjoint from rx2. the idea is that rxa is contained in rx1 + cut r_exa. *)
     apply (rule_tac r_s="comp_use_env rx1 (cut_use_env r_exa)" in disj_leq_use_env1)
      apply (rule_tac disj_comp_use_env1)
       apply (simp)
      apply (rule_tac r_s="r_s2a" in disj_leq_use_env2)
       apply (simp add: disj_use_env_def)
       apply (auto)
        apply (rule_tac r_s="r_s1" in swp_mini_disj_use_env)
        apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac self_cut_leq_use_env)
        apply (simp)
       apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
        apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac self_cut_leq_use_env)
        apply (simp)
       apply (rule_tac strong_cut_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac st_diff_comp_leq_use_env)
     apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac diff_cut_leq_use_env)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac well_typed_state_non_prim_env)
      apply (auto)
    (* - proving initial boundary changes *)
    apply (rule_tac dist_comp_leq_use_env)
     apply (simp)
    apply (rule_tac dist_comp_leq_use_env)
     apply (simp)
    apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (auto)
   (*apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)*)
   apply (rule_tac r_sb="diff_use_env (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)) r_exa" in trans_leq_use_env)
    apply (rule_tac fold_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 r_exa" in trans_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac self_comp_leq_use_env1)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac st_diff_comp_leq_use_env)
      apply (simp)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac self_comp_leq_use_env1)
   apply (rule_tac mini_disj_diff_leq_use_env)
    apply (simp)
   apply (rule_tac r_s="diff_use_env r_s1 r_exa" in mini_disj_leq_use_env2)
    apply (rule_tac mini_disj_diff_use_env)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
    (* - secondary boundary change. *)
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac unroll_dcl_use_env)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac rhs_flip_use_env)
  apply (rule_tac rhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac lhs_fold_dcl_use_env)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac lhs_dist_dcl_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (simp)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac self_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env1)
   apply (rule_tac self_comp_leq_use_env2)
    (* special pair reduction case *)
  apply (case_tac "\<not> (\<exists> p. ax = MakeAct p)")
   apply (auto)
   apply (case_tac x61a)
        apply (auto)
   apply (case_tac x1)
                apply (auto)
    (* - prelim: proving the end type *)(*
  apply (case_tac "tau \<noteq> PairTy t1a t1")
   apply (case_tac "\<not> (\<exists> t1b t2. FunTy t1a (FunTy t1 tau r a) ra aa = take_fun t1b (take_fun t2 (PairTy t1b t2) Aff) NoAff)")
    apply (case_tac x61a)
         apply (auto)
    apply (case_tac x1)
                 apply (auto)
   apply (simp add: take_fun_def)
   apply (case_tac "is_unique t1b")
    apply (auto)
    apply (case_tac "is_unique t2")
     apply (auto)
   apply (case_tac "is_unique t2")
    apply (auto)
  apply (rule_tac x="add_env env p tau" in exI)
  apply (auto)*)
  apply (case_tac "tau \<noteq> PairTy t1a t1")
   apply (case_tac "\<not> (\<exists> t1b t2. FunTy t1a (FunTy t1 tau r a) ra aa = pure_fun t1b (pure_fun t2 (PairTy t1b t2)))")
    apply (case_tac x61a)
         apply (auto)
    apply (case_tac x1)
                 apply (auto)
   apply (simp add: pure_fun_def)
    (* - well-typedness statement *)
  apply (rule_tac x="tau" in exI)
  apply (auto)
    apply (case_tac x61a)
         apply (auto)
    apply (case_tac "x1 \<noteq> PairConst")
    apply (case_tac "x1")
                  apply (auto)
      apply (simp add: add_env_def)
     apply (rule_tac req_leq_use_envx)
     apply (simp add: add_use_env_def)
    (* - to prove the end perm bound, we have to prove that r_s2 does not contain x62a or x62 (it should have been removed in e2),
        and it doesn't contain p (p is fresh) *)
    apply (rule_tac x="comp_use_env (one_use_env p OwnPerm) r_ex" in exI)
    apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s1 r_ex" in trans_leq_use_env)
       apply (rule_tac rhs_unroll_dcl_use_env)
       apply (rule_tac rhs_unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac r_sb="diff_use_env (add_use_env r_s1 p OwnPerm) (one_use_env p OwnPerm)" in trans_leq_use_env)
        apply (rule_tac rhs_fold_dcl_use_env)
        apply (rule_tac dist_diff_leq_use_env_gen)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac req_leq_use_envx)
         apply (simp add: one_use_env_def)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac rhs_unroll_rem_use_env)
       apply (rule_tac rhs_rem_leq_use_env)
        apply (simp add: fresh_var_def)
        apply (simp add: valid_use_env_def)
        apply (simp add: sub_use_env_def)
       apply (rule_tac rhs_add_leq_use_env)
        apply (rule_tac id_leq_use_env)
       apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac lhs_unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
        apply (rule_tac r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa)" in trans_leq_use_env)
         apply (rule_tac r_sb="r_s2aa" in trans_leq_use_env)
          apply (simp_all)
       apply (rule_tac diff_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac diff_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac dist_comp_leq_use_env)
      apply (simp add: leq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: add_use_env_def)
     apply (rule_tac rhs_add_leq_use_env)
      apply (simp)
     apply (case_tac "r_ex p")
       apply (auto)
    apply (simp add: leq_use_env_def)
    apply (simp add: diff_use_env_def)
    apply (simp add: minus_use_env_def)
    apply (simp add: req_use_env_def)
    apply (simp add: one_use_env_def)
    apply (simp add: neg_use_env_def)
    apply (simp add: comp_use_env_def)
    apply (case_tac "start_req_perm tau")
      apply (auto)
    (* - well-typed state *)
  apply (case_tac x61a)
       apply (auto)
  apply (case_tac x1)
               apply (auto)
    (* - prelim: neither x62a nor x62 will result in primitive types *)
  apply (simp add: app_req_def)
    (* - updating resource map *)
  apply (rule_tac x="add_mem rs_map p (norm_use_env r_s2aa (res_use_env rs_map))" in exI)
  apply (auto)
    (* - well-typed state add vars lemma, designed for the addition of new resources *)
   apply (rule_tac well_typed_state_add_vars)
      apply (auto)
    apply (cut_tac env="env" and ?r_s1.0="r_s2aa" and e="x62a" and rx="rx2a" in infl_full_sexp_wp)
      apply (auto)
     apply (case_tac x62a)
          apply (auto)
    apply (cut_tac env="env" and ?r_s1.0="r_s2a" and e="x62" and rx="rx2" in infl_full_sexp_wp)
      apply (auto)
(*
      apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
       apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa)" in trans_leq_use_env)
       apply (rule_tac diff_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)*)
     apply (case_tac x62)
          apply (auto)
    apply (case_tac "ra = OwnPerm")
     apply (simp add: pure_fun_def)
    apply (case_tac ra)
      apply (auto)
    apply (case_tac "r = OwnPerm")
     apply (simp add: pure_fun_def)
    apply (case_tac r)
      apply (auto)
    apply (rule_tac x="comp_use_env rx2a (infl_use_env r_s2aa r_s3a)" in exI)
    apply (rule_tac x="comp_use_env rx2 (infl_use_env r_s2a r_s3)" in exI)
    apply (auto)
    (* disjointness *)
      apply (rule_tac disj_comp_use_env1)
    (* - to prove rx2a | rx2 + [r_s2a - r_s3], we use a disjointness result to ease the problem to rx2a - EX | rx2 + [r_s2a - r_s3],
          which is possible since EX <| rx2 + [r_s2a - r_s3], since rx2 + [r_s2a - r_s3] \<le> r_s2a \<le> r_s3a - EX. *)
       apply (rule_tac r_ex="comp_use_env (comp_use_env rx1a rx2a) r_exa" in lease_disj_use_env2)
    (* - from there we further ease the problem to rx1 | rx2 + [r_s2a - r_s3], which is true for rx2 trivially, for [r_s2a - r_s3] by
          inflection disjointness, since rx1 \<le> r_s3. *)
        apply (rule_tac r_s="rx1" in disj_leq_use_env1)
         apply (rule_tac disj_comp_use_env2)
          apply (simp)
         apply (rule_tac infl_disj_use_env)
         apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
          apply (simp)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac r_sb="diff_use_env (comp_use_env rx1a rx2a) (comp_use_env (comp_use_env rx1a rx2a) r_exa)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac dist_diff_leq_use_env)
        apply (rule_tac self_comp_leq_use_env2)
    (* - it remains simply to prove the semi-disjointess requirement EX <| rx2 + [r_s2a - r_s3] *)
       apply (rule_tac r_s="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a rx2a) r_exa)" in mini_disj_leq_use_env2)
        apply (rule_tac r_s="comp_use_env (comp_use_env rx1a rx2a) r_exa" in mini_disj_leq_use_env1)
         apply (rule_tac mini_disj_diff_use_env)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
         apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
          apply (rule_tac well_typed_perm_leq)
          apply (auto)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac self_infl_leq_use_env)
    (* - to prove [r_s2aa - r_s3a] | rx2 + [r_s2a r_s3], we can simply use inflection disjointness *)
      apply (rule_tac comm_disj_use_env)
      apply (rule_tac infl_disj_use_env)
      apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
       apply (rule_tac r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a rx2a) r_exa)" in trans_leq_use_env)
        apply (rule_tac self_diff_leq_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
        apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac self_infl_leq_use_env)
    (* well-typedness, we use a lemma to prove restricting it to rs_map is valid *)
     apply (rule_tac t="norm_use_env r_s2aa (res_use_env rs_map)" and s="r_s2aa" in subst)
      apply (cut_tac r_s="r_s2aa" and rs_map="rs_map" in norm_res_use_env)
       apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
        apply (rule_tac norm_res_leq_use_env)
         apply (auto)
    (* second well-typedness *)
    apply (rule_tac t="norm_use_env r_s2aa (res_use_env rs_map)" and s="r_s2aa" in subst)
     apply (cut_tac r_s="r_s2aa" and rs_map="rs_map" in norm_res_use_env)
      apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
       apply (rule_tac norm_res_leq_use_env)
        apply (auto)
    apply (rule_tac r_s="r_s2a" in well_typed_incr_simul_perm)
     apply (rule_tac r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a rx2a) r_exa)" in trans_leq_use_env)
      apply (rule_tac diff_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
    (* scoping satisfied by design *)
   apply (rule_tac norm_scope_use_env)
    (* validity of use env *)
  apply (simp add: valid_use_env_def)
  apply (rule_tac rhs_add_sub_use_env)
   apply (rule_tac add_sub_use_env)
   apply (simp)
  apply (simp add: add_env_def)
  done
    

    (*
(*
lemma safe_app_red_exp: "\<lbrakk> well_typed env r_s1 e1 tau r_s2 rx; well_typed_state s1 env rx_res; leq_res_map r_s1 rx_res;
  app_red_exp (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> (\<exists> env' r_xe r_se. well_typed env' (red_use_env r_s1 ax) e2 tau r_se r_xe \<and>
  red_env env ax env' \<and> well_typed_state s2 env' rx_res \<and> leq_res_map (red_use_env r_s1 ax) rx_res)"
  apply (case_tac e1)
       apply (auto)
   apply (case_tac x41)
        apply (auto)
   apply (case_tac x1)
      apply (auto)
   apply (case_tac x3)
    apply (auto)
    (* if case 1 *)
    apply (case_tac ax)
     apply (auto)
    apply (rule_tac x="rx1" in exI)
    apply (rule_tac x="r_s2" in exI)
    apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
     apply (auto)
    (* if case 2 *)
   apply (case_tac ax)
    apply (auto)
   apply (rule_tac x="rx2" in exI)
   apply (rule_tac x="r_s2" in exI)
   apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
    apply (auto)
    (* app unrolling *)
  apply (case_tac x61)
       apply (auto)
    (* fix const *)
    apply (case_tac "x1 = FixConst")
     apply (auto)
     apply (case_tac ax)
      apply (auto)
      apply (case_tac x62)
           apply (auto)
      apply (simp add: pure_fun_def)
      apply (auto)
      apply (rule_tac ?e1.0="x52" and x="x51" and t="tau" and ?rx1.0="rxa" and r="UsePerm" and r_s'="r_s'" and r_end="r_end"
        and e'="AppExp (ConstExp FixConst) (LamExp x51 x52)" and ?r_s2.0="r_s2a" and ?r_s3.0="r_s2a" and ?rx2.0="rxa" in safe_subst_type_preserve)
               apply (auto)
          apply (rule_tac x="pure_fun tau tau" in exI)
          apply (rule_tac x="UsePerm" in exI)
          apply (auto)
           apply (simp add: pure_fun_def)
          apply (rule_tac x="r_s2a" in exI)
          apply (auto)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac x="rxa" in exI)
          apply (auto)
          apply (rule_tac x="rxa" in exI)
          apply (rule_tac x="r_s2a" in exI)
          apply (auto)
           apply (simp add: pure_fun_def)
           apply (rule_tac x="rxa" in exI)
           apply (auto)
           apply (rule_tac x="empty_use_env" in exI)
           apply (auto)
             apply (rule_tac rhs_weak_leq_use_env)
              apply (simp add: weak_use_env_def)
              apply (simp add: empty_use_env_def)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac leq_empty_use_env)
           apply (rule_tac self_diff_leq_use_env)
          apply (rule_tac x="empty_use_env" in exI)
          apply (auto)
                apply (rule_tac rhs_weak_leq_use_env)
                 apply (rule_tac dist_weak_comp_use_env)
                  apply (simp add: aff_use_env_def)
                  apply (rule_tac dist_weak_comp_use_env)
                   apply (simp_all)
                 apply (simp add: weak_use_env_def)
                 apply (simp add: empty_use_env_def)
                apply (rule_tac id_leq_use_env)
               apply (simp add: aff_use_env_def)
               apply (simp add: weak_use_env_def)
              apply (simp add: pure_fun_def)
             apply (rule_tac dist_comp_leq_use_env)
              apply (simp_all)
            apply (rule_tac double_weak_disj_use_env)
             apply (simp add: aff_use_env_def)
            apply (simp add: aff_use_env_def)
           apply (rule_tac leq_empty_use_env)
          apply (simp add: app_req_def)
          apply (auto)
           apply (rule_tac leq_empty_use_env)
          apply (rule_tac diff_leq_use_env)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
          apply (simp_all)
        apply (rule_tac dist_comp_leq_use_env)
         apply (simp_all)
       apply (simp add: aff_use_env_def)
       apply (simp add: weak_use_env_def)
      apply (case_tac tau)
            apply (auto)
      apply (rule_tac double_weak_disj_use_env)
       apply (simp add: aff_use_env_def)
      apply (simp add: aff_use_env_def)
    (* - same state proof *)
     apply (case_tac x62)
          apply (auto)
    (* other *)
        apply (case_tac x1)
                 apply (auto)
    (* other constant cases *)(*
    apply (cut_tac env="env" and ?r_s1.0="r_s1" and c="x1" and v="x62" in safe_app_const_case)
        apply (auto)
     apply (rule_tac x="t1" in exI)
     apply (rule_tac x="r" in exI)
       apply (auto)
       apply (rule_tac x="r_s2a" in exI)
       apply (auto)
      apply (rule_tac x="env'" in exI)
      apply (auto)
       apply (case_tac ax)
        apply (auto)
    (* - same state proof *)
        apply (case_tac x1)
                    apply (auto)
         apply (case_tac x62)
              apply (auto)
         apply (case_tac x32)
          apply (auto)
        apply (case_tac x62)
             apply (auto)
        apply (case_tac x32)
       apply (auto)
      apply (simp add: well_typed_state_def)
      apply (auto)
      apply (erule_tac x="aa" in allE)
      apply (auto)
      apply (case_tac "x = aa")
       apply (simp add: add_mem_def)
       apply (auto)
       apply (case_tac "env aa")
        apply (auto)
       apply (rule_tac x="ta" in exI)
    *)
    (* op case *)
   apply (case_tac ax)
    apply (auto)
    apply (rule_tac x="empty_use_env" in exI)
    apply (rule_tac x="r_s1" in exI)
    apply (rule_tac safe_app_op_case)
     apply (auto)
   apply (case_tac x62)
        apply (auto)
    (* lam case *)
  apply (case_tac ax)
   apply (auto)
  apply (rule_tac x="x51" and t="t1" and ?rx1.0="rxa" and r="r" and ?e1.0="x52" and r_s'="r_s'" and r_end="r_end"
    and e'="x62" and ?r_s2.0="comp_use_env r_s2a (cut_use_env r_exa)" and ?r_s3.0="comp_use_env r_s3 (cut_use_env r_exa)" and ?rx2.0="rx2" in safe_subst_type_preserve)
           apply (auto)
      apply (case_tac x62)
           apply (auto)
     apply (rule_tac well_typed_comp_perms_gen)
      apply (auto)
     apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
      apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac self_cut_leq_use_env)
      apply (simp)
     apply (rule_tac strong_cut_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (simp)
    apply (rule_tac cut_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac st_diff_comp_leq_use_env)
    apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
     apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac comp_leq_use_env1)
     apply (simp)
    apply (rule_tac diff_cut_leq_use_env)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (simp)
   apply (rule_tac self_comp_leq_use_env2)
    (* the last thing we have to do is show that rxa is disjoint from rx2. the idea is that rxa is contained in rx1 + cut r_exa. *)
  apply (rule_tac r_s="comp_use_env rx1 (cut_use_env r_exa)" in disj_leq_use_env1)
   apply (rule_tac disj_comp_use_env1)
    apply (simp)
   apply (rule_tac r_s="r_s2a" in disj_leq_use_env2)
    apply (simp add: disj_use_env_def)
    apply (auto)
     apply (rule_tac r_s="r_s1" in swp_mini_disj_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
      apply (rule_tac dist_diff_leq_use_env_gen)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac self_cut_leq_use_env)
     apply (simp)
    apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
      apply (rule_tac dist_diff_leq_use_env_gen)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac self_cut_leq_use_env)
     apply (simp)
    apply (rule_tac strong_cut_use_env)
   apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
   apply (rule_tac self_comp_leq_use_env2)
  apply (rule_tac st_diff_comp_leq_use_env)
  apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac diff_cut_leq_use_env)
  apply (rule_tac id_leq_use_env)
  done  *)
  
*)

definition disj_trap where
  "disj_trap c1 c2 = (c1 \<or> c2)"
    
fun c_red_exp :: "p_state \<times> p_exp \<Rightarrow> p_act \<Rightarrow> p_state \<times> p_exp \<Rightarrow> bool" where
  "c_red_exp (s, e) a (s', e') = disj_trap (app_red_exp (s, e) a (s', e')) (case e of
    AppExp e1 e2 \<Rightarrow> (\<exists> e2'. AppExp e1 e2' = e' \<and> is_sexp e1 \<and> c_red_exp (s, e2) a (s', e2')) \<or>
      (\<exists> e1'. AppExp e1' e2 = e' \<and> c_red_exp (s, e1) a (s', e1'))
    | other \<Rightarrow> False
  )"    
   
fun f_red_exp :: "p_state \<times> p_exp \<Rightarrow> p_act \<Rightarrow> p_state \<times> p_exp \<Rightarrow> bool" where
  "f_red_exp (s, AppExp e1 e2) a (s', e') = disj_trap (app_red_exp (s, AppExp e1 e2) a (s', e')) (
      (\<exists> e2'. AppExp e1 e2' = e' \<and> is_sexp e1 \<and> f_red_exp (s, e2) a (s', e2')) \<or>
      (\<exists> e1'. AppExp e1' e2 = e' \<and> f_red_exp (s, e1) a (s', e1'))
  )"
| "f_red_exp (s, other) a (s', e') = False"
      
  

    

    

fun safe_act where
  "safe_act s NoAct = True"
| "safe_act s (MakeAct x) = (s x = None)"
| "safe_act s (UseAct x) = True"
    
(*well_typed (red_env env (AppExp e11 e2') tau' ax) (red_use_env r_s1 (AppExp e11 e2') ax) e11 (FunTy t1 tau r a) (red_use_env r_s1 e2 ax)
            (comp_use_env rx1 (infl_use_env r_s1 r_s2a))*)  
  
lemma well_typed_red_vars: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; free_vars e \<subseteq> free_vars e'; safe_act s ax; sub_env s env \<rbrakk> \<Longrightarrow>
  well_typed (red_env env t ax) r_s1 e tau r_s2 rx"    
  apply (case_tac ax)
    apply (auto)
   apply (rule_tac x="x2" and t="t" in well_typed_add_vars)
    apply (auto)
   apply (cut_tac env="env" and x="x2" and e="e" in well_typed_fv_env_use)
     apply (auto)
   apply (simp add: sub_env_def)(*
  apply (rule_tac well_typed_rem_vars)
   apply (auto)*)
  done    
    
lemma safe_act_well_typed_app: "\<lbrakk> well_typed env r_s1 e1 tau r_s2 rx; app_red_exp (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> safe_act s1 ax"    
  apply (case_tac e1)
       apply (auto)
   apply (case_tac ax)
     apply (auto)
   apply (case_tac ax)
     apply (auto)
    (* if case *)
   apply (case_tac x41)
        apply (auto)
   apply (case_tac x1)
                apply (auto)
   apply (case_tac x3)
    apply (auto)
    (* case analysis on constants for make action *)
  apply (case_tac x61)
       apply (auto)
    apply (case_tac x1)
                 apply (auto)
     apply (case_tac x62)
          apply (auto)
    apply (simp add: fresh_var_def)
    (* case analysis for op *)
   apply (case_tac x62)
        apply (auto)
    (* case analysis for pair creation *)
  apply (case_tac x61a)
       apply (auto)
  apply (case_tac x1)
               apply (auto)
  apply (simp add: fresh_var_def)
  done
    
lemma safe_act_well_typed: "\<lbrakk> well_typed env r_s1 e1 tau r_s2 rx; f_red_exp (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> safe_act s1 ax"
  apply (case_tac "app_red_exp (s1, e1) ax (s2, e2)")
   apply (rule_tac safe_act_well_typed_app)
    apply (auto)
  apply (induct e1 arbitrary: env r_s1 tau r_s2 rx e2)
       apply (auto)
  apply (simp add: disj_trap_def)
  apply (auto)
   apply (cut_tac ?r_s1.0="r_s2a" and r_c="r_s1" and e="e12" in well_typed_incr_start_perm)
     apply (auto)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (case_tac "app_red_exp (s1, e12) ax (s2, e2')")
    apply (rule_tac safe_act_well_typed_app)
      apply (auto)
  apply (case_tac "app_red_exp (s1, e11) ax (s2, e1')")
   apply (auto)
  apply (rule_tac safe_act_well_typed_app)
   apply (auto)
  done
   (*
lemma red_leq_use_env: "leq_use_env r_s (red_use_env r_s ax)"
  apply (case_tac ax)
   apply (auto)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac rhs_add_leq_use_env)
   apply (rule_tac id_leq_use_env)
  apply (case_tac "r_s x2")
    apply (auto)
  done
     *)
lemma mini_disj_infl_use_env: "mini_disj_use_env (infl_use_env r_s r_x) r_x"
  apply (simp add: infl_use_env_def)
  apply (simp add: mini_disj_use_env_def)
  done

lemma mini_disj_infl_use_env2: "mini_disj_use_env r_x (infl_use_env r_s r_x)"
  apply (simp add: infl_use_env_def)
  apply (simp add: mini_disj_use_env_def)
  done

lemma disj_infl_use_env: "disj_use_env (infl_use_env r_s r_x) r_x"
  apply (simp add: disj_use_env_def)
  apply (simp add: infl_use_env_def)
  apply (simp add: mini_disj_use_env_def)
  done    
    
lemma well_typed_add_permsx: "\<lbrakk> well_typed env r_s1 e tau r_s2 rx; x \<notin> free_vars e; r = OwnPerm \<rbrakk> \<Longrightarrow>
  well_typed env (add_use_env r_s1 x r) e tau (add_use_env r_s2 x r) rx"
  apply (rule_tac rx="rem_use_env rx x" in well_typed_incr_req)
    apply (cut_tac r_s="r_s1" and x="x" and r="r" in partial_add_rem_use_env)
    apply (cut_tac r_s="r_s2" and x="x" and r="r" in partial_add_rem_use_env)
  (*apply (cut_tac r_s="rx" and x="x" in ignore_rem_use_env)
   apply (simp)*)
    apply (cut_tac r_s="rem_use_env r_s1 x" and x="x" and r="r" in add_comp_use_env)
     apply (auto)
    apply (cut_tac r_s="rem_use_env r_s2 x" and x="x" and r="r" in add_comp_use_env)
     apply (auto)
    apply (rule_tac well_typed_comp_perms_gen)
     apply (rule_tac well_typed_rem_perms)
      apply (auto)
    apply (simp add: mini_disj_use_env_def)
    apply (simp add: one_use_env_def)
    apply (simp add: rem_use_env_def)
   apply (rule_tac self_rem_leq_use_env)
    apply (rule_tac rhs_add_leq_use_env)
   apply (cut_tac env="env" and ?r_s1.0="r_s1" and e="e" and tau="tau" and ?r_s2.0="r_s2" and rx="rx" and x="x" in well_typed_rem_perms)
     apply (auto)
  apply (rule_tac well_typed_perm_leqx)
  apply (auto)
  done    

lemma well_typed_red_permsx: "\<lbrakk> well_typed env r_s e tau r_s rx; safe_act s ax; sub_env s env \<rbrakk> \<Longrightarrow>
  well_typed env (red_use_env r_s ax) e tau (red_use_env r_s ax) rx"     
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac well_typed_add_permsx)
    apply (simp)
   apply (case_tac "x2 \<in> free_vars e")
    apply (cut_tac env="env" and x="x2" and e="e" in well_typed_fv_env_use)
      apply (auto)
  apply (simp add: sub_env_def)
  done
    
lemma well_typed_red_perms: "\<lbrakk> well_typed env r_s e tau r_s rx; safe_act s ax; sub_env s env \<rbrakk> \<Longrightarrow>
  well_typed env (red_use_env r_s ax) e tau (red_use_env r_s ax) (red_use_env rx ax)"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac rx="rx" in well_typed_incr_req)
    apply (rule_tac well_typed_add_permsx)
      apply (simp)
     apply (case_tac "x2 \<in> free_vars e")
      apply (cut_tac env="env" and x="x2" and e="e" in well_typed_fv_env_use)
        apply (auto)
    apply (simp add: sub_env_def)
   apply (rule_tac rhs_add_leq_use_env)
    apply (rule_tac id_leq_use_env)
   apply (case_tac "rx x2")
     apply (auto)
  apply (rule_tac dist_add_leq_use_env)
  apply (rule_tac well_typed_perm_leqx)
  apply (auto)(*
  apply (rule_tac well_typed_rem_perms)
   apply (auto)*)
  done
    
lemma diff_infl_leq_use_env: "leq_use_env (diff_use_env (infl_use_env r_s r_x) (infl_use_env r_s r_x)) empty_use_env"
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: minus_use_env_def)
  apply (simp add: neg_use_env_def)
  apply (simp add: infl_use_env_def)
  done
    
  (*
lemma exp_red_leq_use_env: "\<lbrakk> free_vars e \<subseteq> free_vars e' \<rbrakk> \<Longrightarrow> leq_use_env (red_use_env r_s ax) (red_use_env r_s ax)"    
  apply (case_tac ax)
    apply (auto)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac id_leq_use_env)(*
   apply (rule_tac self_rem_leq_use_env)
  apply (rule_tac id_leq_use_env)*)
  done*)
    
    (*
lemma exp_contain_env: "\<lbrakk> free_vars e \<subseteq> free_vars e' \<rbrakk> \<Longrightarrow> contain_env (red_env env tau ax) (red_env env tau ax)"    
  apply (case_tac ax)
    apply (auto)
      apply (rule_tac id_contain_env)
     apply (rule_tac id_contain_env)
    apply (rule_tac id_contain_env)
   apply (rule_tac self_rem_contain_env)
  apply (rule_tac id_contain_env)
  done*)
    
lemma well_typed_contain_env: "\<lbrakk> well_typed env' r_s1 e tau r_s2 rx; contain_env env env' \<rbrakk> \<Longrightarrow> well_typed env r_s1 e tau r_s2 rx"    
  apply (induct e arbitrary: env env' r_s1 tau r_s2 rx)
       apply (auto)
     apply (simp add: contain_env_def)
     apply (erule_tac x="x1a" in allE)
     apply (auto)
    apply (rule_tac x="rx'" in exI)
    apply (rule_tac x="r_s2a" in exI)
    apply (auto)
    apply (rule_tac x="rx1" in exI)
    apply (auto)
    apply (rule_tac x="rx2" in exI)
    apply (auto)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
   apply (rule_tac x="r_end" in exI)
   apply (rule_tac x="r_s'" in exI)
   apply (cut_tac r_s="env" and r_x="env'" and x="x1a" and t="t1" in dist_add_contain_env)
    apply (auto)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="r_s2a" in exI)
  apply (rule_tac x="rx1" in exI)
  apply (auto)
  apply (rule_tac x="rx2" in exI)
  apply (rule_tac x="r_s3" in exI)
  apply (auto)
  done
    
lemma comp_red_leq_use_env: "leq_use_env (red_use_env (comp_use_env r_s r_x) ax) (comp_use_env (red_use_env r_s ax) r_x)"    
  apply (case_tac ax)
    apply (auto)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac add_leq_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_add_leq_use_env)
     apply (case_tac "r_s x2")
       apply (auto)
    apply (rule_tac self_comp_leq_use_env2)
   apply (simp add: comp_use_env_def)
   apply (simp add: add_use_env_def)
  apply (rule_tac id_leq_use_env)(*
  apply (rule_tac t="rem_use_env (comp_use_env r_s r_x) x3" and s="comp_use_env (rem_use_env r_s x3) (rem_use_env r_x x3)" in subst)
   apply (cut_tac r_s="r_s" and r_x="r_x" and x="x3" in dist_rem_comp_use_env)
   apply (simp)
  apply (rule_tac id_leq_use_env)*)
  done
  
lemma rhs_unroll_add_use_env: "leq_use_env r_x (rem_use_env (diff_use_env r_sa r_sb) x) \<Longrightarrow> leq_use_env r_x (diff_use_env r_sa (add_use_env r_sb x OwnPerm))"    
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: minus_use_env_def)
  apply (simp add: neg_use_env_def)
  apply (simp add: rem_use_env_def)
  apply (simp add: add_use_env_def)
  apply (auto)
   apply (erule_tac x="x" in allE)
   apply (auto)
   apply (case_tac "r_x x")
     apply (auto)
  apply (erule_tac x="xa" in allE)
  apply (auto)
  done(*
  
lemma end_red_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow>
  leq_use_env (end_red_use_env r_x e ax) r_s"        
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac rem_leq_use_env)
  apply (simp)
  done

lemma end_red_leq_use_env2: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow>
  leq_use_env (end_red_use_env r_x e ax) (red_use_env r_s e ax)"        
  apply (case_tac ax)
    apply (auto)
   apply (rule_tac rhs_add_leq_use_env)
    apply (simp)
   apply (case_tac "r_x x2")
     apply (auto)
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)
  done    
    
lemma diff_end_red_leq_use_env_ex: "\<lbrakk> leq_use_env r_x (diff_use_env r_sa r_sb); sub_use_env s r_x; safe_act s ax \<rbrakk> \<Longrightarrow>
  leq_use_env r_x (diff_use_env r_sa (end_red_use_env r_sb e ax))"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac r_sb="diff_use_env r_sa r_sb" in trans_leq_use_env)
   apply (rule_tac dist_diff_leq_use_env_gen)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac self_rem_leq_use_env)
  apply (simp)
  done*)
    
lemma diff_red_leq_use_env_ex: "\<lbrakk> leq_use_env r_x (diff_use_env r_sa r_sb); sub_use_env s r_x; safe_act s ax \<rbrakk> \<Longrightarrow>
  leq_use_env r_x (diff_use_env r_sa (red_use_env r_sb ax))"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac rhs_unroll_add_use_env)
  apply (rule_tac rhs_rem_leq_use_env)
   apply (simp add: sub_use_env_def)
  apply (simp)(*
  apply (rule_tac r_sb="diff_use_env r_sa r_sb" in trans_leq_use_env)
   apply (rule_tac dist_diff_leq_use_env_gen)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac self_rem_leq_use_env)
  apply (simp)*)
  done
  
lemma trans_sub_use_env: "\<lbrakk> sub_use_env s r_s; leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> sub_use_env s r_x"    
  apply (simp add: sub_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done
(*
lemma dist_end_red_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (end_red_use_env r_x e ax) (end_red_use_env r_s e ax)"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)
  done    *)
    
lemma dist_red_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (red_use_env r_x ax) (red_use_env r_s ax)"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac dist_add_leq_use_env)
  apply (simp)
(*
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)*)
  done
  
lemma disj_red_use_env: "\<lbrakk> disj_use_env r_s r_x; sub_use_env s r_x; safe_act s ax \<rbrakk> \<Longrightarrow> disj_use_env (red_use_env r_s ax) r_x"
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac disj_add_use_env)
   apply (simp add: sub_use_env_def)
  apply (simp)(*
  apply (rule_tac disj_rem_use_envx)
  apply (simp)*)
  done
   (*
lemma diff_end_red_leq_use_env: "\<lbrakk> leq_use_env r_x (diff_use_env r_s r_ex) \<rbrakk> \<Longrightarrow>
  leq_use_env (end_red_use_env r_x e ax) (diff_use_env (end_red_use_env r_s e ax) r_ex)"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac rhs_fold_rem_use_env)
  apply (rule_tac rhs_fold_dcl_use_env)
  apply (rule_tac rhs_flip_use_env)
  apply (rule_tac rhs_unroll_dcl_use_env)
  apply (rule_tac rhs_unroll_rem_use_env)
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)
  done
    
lemma diff_end_red_leq_use_env2: "\<lbrakk> leq_use_env r_x (diff_use_env r_s r_ex) \<rbrakk> \<Longrightarrow>
  leq_use_env (end_red_use_env r_x e ax) (diff_use_env (red_use_env r_s e ax) r_ex)"    
  apply (case_tac ax)
    apply (auto)
   apply (rule_tac r_sb="diff_use_env r_s r_ex" in trans_leq_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac rhs_add_leq_use_env)
     apply (rule_tac id_leq_use_env)
    apply (case_tac "r_s x2")
      apply (auto)
  apply (rule_tac rhs_fold_rem_use_env)
  apply (rule_tac rhs_fold_dcl_use_env)
  apply (rule_tac rhs_flip_use_env)
  apply (rule_tac rhs_unroll_dcl_use_env)
  apply (rule_tac rhs_unroll_rem_use_env)
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)
  done
    
lemma dist_diff_end_red_leq_use_env: "\<lbrakk> leq_use_env (diff_use_env r_x r_ex) r_s \<rbrakk> \<Longrightarrow>
  leq_use_env (diff_use_env (end_red_use_env r_x e ax) (end_red_use_env r_ex e ax)) (end_red_use_env r_s e ax)"    
  apply (case_tac ax)
    apply (auto)
  apply (case_tac "\<not> diff_use_env (rem_use_env r_x x3) (rem_use_env r_ex x3) = rem_use_env (diff_use_env r_x r_ex) x3")
   apply (cut_tac r_s="r_x" and r_x="r_ex" and x="x3" in dist_diff_rem_use_env)
   apply (auto)
  apply (rule_tac dist_rem_leq_use_env)
  apply (simp)
  done
  
lemma lhs_unroll_ercl_use_env: "\<lbrakk> leq_use_env (comp_use_env (end_red_use_env r_x e ax) (end_red_use_env r_s e ax)) r_ex \<rbrakk> \<Longrightarrow>
  leq_use_env (end_red_use_env (comp_use_env r_x r_s) e ax) r_ex"    
  apply (case_tac ax)
    apply (auto)
  apply (cut_tac r_s="r_x" and r_x="r_s" and x="x3" in dist_rem_comp_use_env)
  apply (auto)
  done
  
lemma lift_end_red_leq_use_env: "leq_use_env (lift_use_env (end_red_use_env r_s e ax) r) (end_red_use_env (lift_use_env r_s r) e ax)"    
  apply (case_tac ax)
    apply (auto)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac id_leq_use_env)
   apply (cut_tac r_s="r_s" and x="x3" and r="r" in lift_rem_use_env)
   apply (simp)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac id_leq_use_env)
  done
    
lemma lift_end_red_leq_use_envx: "leq_use_env (end_red_use_env (lift_use_env r_s r) e ax) (lift_use_env (end_red_use_env r_s e ax) r)"     
  apply (case_tac ax)
    apply (auto)
    apply (rule_tac id_leq_use_env)
    apply (rule_tac id_leq_use_env)
   apply (cut_tac r_s="r_s" and x="x3" and r="r" in lift_rem_use_env)
   apply (simp)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac id_leq_use_env)
  done
    
lemma safe_lift_end_red_use_env: "\<lbrakk> safe_use_lift r_s r \<rbrakk> \<Longrightarrow> safe_use_lift (end_red_use_env r_s e ax) r"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac safe_lift_rem_use_env)
  apply (simp)
  done
  
lemma well_typed_red_simul_permx: "\<lbrakk> well_typed env (end_red_use_env r_s1 ex ax) e tau (end_red_use_env r_s2 ex ax) (end_red_use_env rx ex ax); leq_use_env r_s2 r_s1;
  leq_use_env rx r_s2; free_vars ex \<subseteq> free_vars ex' \<rbrakk> \<Longrightarrow> well_typed env (end_red_use_env r_s1 ex' ax) e tau (end_red_use_env r_s2 ex' ax) (end_red_use_env rx ex' ax)"    
  apply (case_tac ax)
    apply (auto)
   apply (case_tac "x3 \<notin> free_vars ex")
    apply (auto)
  apply (case_tac "x3 \<notin> free_vars ex")
   apply (auto)
  apply (rule_tac t="r_s1" and s="add_use_env (rem_use_env r_s1 x3) x3 (r_s1 x3)" in subst)
   apply (cut_tac r_s="r_s1" and x="x3" and r="r_s1 x3" in cancel_add_rem_use_env)
    apply (auto)
  apply (rule_tac t="r_s2" and s="add_use_env (rem_use_env r_s2 x3) x3 (r_s2 x3)" in subst)
   apply (cut_tac r_s="r_s2" and x="x3" and r="r_s2 x3" in cancel_add_rem_use_env)
    apply (auto)
  apply (rule_tac rx="rem_use_env rx x3" in well_typed_incr_req)
    apply (rule_tac ?r_s1.0="add_use_env (rem_use_env r_s1 x3) x3 (r_s2 x3)" in well_typed_incr_start_perm)
     apply (cut_tac r_s="rem_use_env r_s1 x3" and x="x3" and r="r_s2 x3" in add_comp_use_env)
      apply (simp add: rem_use_env_def)
     apply (cut_tac r_s="rem_use_env r_s2 x3" and x="x3" and r="r_s2 x3" in add_comp_use_env)
      apply (simp add: rem_use_env_def)
     apply (auto)
     apply (rule_tac well_typed_comp_perms_gen)
      apply (simp)
     apply (simp add: mini_disj_use_env_def)
     apply (simp add: rem_use_env_def)
     apply (simp add: one_use_env_def)
    apply (rule_tac dist_add_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (simp add: leq_use_env_def)
   apply (rule_tac self_rem_leq_use_env)
  apply (cut_tac r_s="r_s2" and x="x3" in cancel_add_rem_use_env)
   apply (auto)
  done*)
    
lemma red_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env r_x (red_use_env r_s ax)"    
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac rhs_add_leq_use_env)
   apply (simp)
  apply (case_tac "r_x x2")
    apply (auto)
  done
  (*
lemma well_typed_red_simul_perm: "\<lbrakk> well_typed env (red_use_env r_s1 ax) e tau r_s2 rx; (*leq_use_env r_s2 r_s1;
  leq_use_env rx r_s2;*) free_vars ex \<subseteq> free_vars ex' \<rbrakk> \<Longrightarrow> well_typed env (red_use_env r_s1 ax) e tau r_s2 rx"    
  apply (case_tac ax)
    apply (auto)(*
   apply (case_tac "x3 \<notin> free_vars ex")
    apply (auto)
  apply (case_tac "x3 \<notin> free_vars ex")
   apply (auto)
  apply (rule_tac t="r_s1" and s="add_use_env (rem_use_env r_s1 x3) x3 (r_s1 x3)" in subst)
   apply (cut_tac r_s="r_s1" and x="x3" and r="r_s1 x3" in cancel_add_rem_use_env)
    apply (auto)
  apply (rule_tac t="r_s2" and s="add_use_env (rem_use_env r_s2 x3) x3 (r_s2 x3)" in subst)
   apply (cut_tac r_s="r_s2" and x="x3" and r="r_s2 x3" in cancel_add_rem_use_env)
    apply (auto)
  apply (rule_tac rx="rem_use_env rx x3" in well_typed_incr_req)
    apply (rule_tac ?r_s1.0="add_use_env (rem_use_env r_s1 x3) x3 (r_s2 x3)" in well_typed_incr_start_perm)
     apply (cut_tac r_s="rem_use_env r_s1 x3" and x="x3" and r="r_s2 x3" in add_comp_use_env)
      apply (simp add: rem_use_env_def)
     apply (cut_tac r_s="rem_use_env r_s2 x3" and x="x3" and r="r_s2 x3" in add_comp_use_env)
      apply (simp add: rem_use_env_def)
     apply (auto)
     apply (rule_tac well_typed_comp_perms_gen)
      apply (simp)
     apply (simp add: mini_disj_use_env_def)
     apply (simp add: rem_use_env_def)
     apply (simp add: one_use_env_def)
    apply (rule_tac dist_add_leq_use_env_gen)
     apply (rule_tac id_leq_use_env)
    apply (simp add: leq_use_env_def)
   apply (rule_tac self_rem_leq_use_env)
  apply (cut_tac r_s="r_s2" and x="x3" in cancel_add_rem_use_env)
   apply (auto)*)
  done*)
  
lemma sre_coerce: "\<lbrakk> (\<And>env r_s1 e2 tau r_s2 rx.
           \<lbrakk>well_typed env r_s1 e tau r_s2 rx; well_typed_state s1 env rs_map; valid_use_env s1 rs_map r_s1; 
            f_red_exp (s1, e) ax (s2, e2); \<not> app_red_exp (s1, e) ax (s2, e2)(*; safe_act env ax*)\<rbrakk>
           \<Longrightarrow> \<exists>tau'. well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e2 tau r_s2 rx \<and>
                      (\<exists>rs_map'. well_typed_state s2 (red_env env tau' ax) rs_map' \<and> valid_use_env s2 rs_map' (red_use_env r_s1 ax)));
  well_typed env r_s1 e tau r_s2 rx; well_typed_state s1 env rs_map; valid_use_env s1 rs_map r_s1;
  f_red_exp (s1, e) ax (s2, e2); \<not> app_red_exp (s1, e) ax (s2, e2)(*; safe_act env ax*) \<rbrakk>
  \<Longrightarrow> (\<exists>tau'. well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e2 tau r_s2 rx \<and>
                      (\<exists>rs_map'. well_typed_state s2 (red_env env tau' ax) rs_map' \<and> valid_use_env s2 rs_map' (red_use_env r_s1 ax)))"
  apply (auto)
  done
    
    (* 
      reduction system: global state, thread local sets of expressions
      type system: global env + perm mapping, thread local perm set

      the main statement we are making is that given e1 \<rightarrow> e2, where e1 is well-typed, e2 is also well-typed.
      e2 may be well-typed under a new env, perm mapping + local perm set.

      the main property is that s2 is also well-typed (getting this involves various constraints on env + rs_map).
      the hard property is ensuring that rs_map remains consistent with all extraneous maps.

      e1 well-typed, s1 well-typed, e1 reduces to e2, "valid" perm set (disjoint from main perm map, subset of s1)
    *)
    (* futures map validity:
        
      no action - r_s1 + rs_map will remain unchanged
      make action - r_s1 will gain 'x', the new resource. rs_map will gain an entry at 'x'
        the resources will be removed from the old r_s1.
      use action - uses include read / write / array ext. if a resource is never used again, it is deleted.
        then, r_s1 will delete 'x'. rs_map will lose permissions at 'x'. if a resource is written to, it may gain permissions.
        then, r_s1 starts unchanged, rs_map will gain permissions at 'x', again removed from the old r_s1.

      the important invariants are, all permissions "added to" rs_map come from r_s1.
      meanwhile r_s1 will only gain permissions if they are completely fresh.
      the easiest way of stating this is that rs_map + r_s1 \<le> their old selves + fresh x
    *)
    
lemma safe_red_exp: "\<lbrakk> well_typed env r_s1 e1 tau r_s2 rx; well_typed_state s1 env rs_map; valid_use_env s1 rs_map r_s1;
  f_red_exp (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> (\<exists> tau' rs_map'.
  well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e2 tau r_s2 rx \<and>
  (*red_env env ax env' \<and>*) well_typed_state s2 (red_env env tau' ax) rs_map' \<and> valid_use_env s2 rs_map' (red_use_env r_s1 ax))"
    (* first we eliminate the case where the reduction is a simple application. (we do this before induction to remove most cases.) *)
  apply (case_tac "app_red_exp (s1, e1) ax (s2, e2)")
   apply (rule_tac safe_app_red_exp_strict)
       apply (auto)
    (* - prelim: one helpful fact is that reduction always produces safe actions *)
  apply (cut_tac ax="ax" and env="env" and ?s1.0="s1" in safe_act_well_typed)
    apply (auto)
    (* if the application is nested, we induct. *)
  apply (induct e1 arbitrary: env r_s1 e2 tau r_s2 rx)
       apply (auto)
  apply (simp add: disj_trap_def)
  apply (auto)
    (* rhs case. within this there are two cases, one where a reduction is performed on e2, and one where we have to induct on e2 *)
    (* - we start by assuming that we are able that the lemma holds on e2
          (which we will prove later either through safe_app or induction)
       - assuming flat permissions (changing r_s2a to (red r_s1)), and increasing the end perms accordingly
          to contain the new reqs (changing r_s3 to r_s3 + (infl r_s1 r_s2a)).
    *)
   apply (case_tac "\<exists>tau'. well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e2' t1
        (comp_use_env r_s3 (infl_use_env r_s1 r_s2a)) rx2 \<and>
        (\<exists>rs_map'. well_typed_state s2 (red_env env tau' ax) rs_map' \<and> valid_use_env s2 rs_map' (red_use_env r_s1 ax))")
    apply (auto)
    (* - we fill in env'. again, e1 needs flat perms to call safe_app, which we are able to do by calling the s-exp lemma. *)
    apply (rule_tac x="tau'" in exI)
    apply (auto)
    apply (rule_tac x="t1" in exI)
    apply (rule_tac x="r" in exI)
    apply (rule_tac x="a" in exI)
    apply (rule_tac x="red_use_env r_s1 ax" in exI)
    apply (rule_tac x="comp_use_env rx1 (infl_use_env r_s1 r_s2a)" in exI)
    apply (auto)
      apply (rule_tac s="s1" in well_typed_red_vars)
         apply (rule_tac well_typed_red_permsx)
          apply (rule_tac infl_full_sexp_wp)
           apply (auto)
      apply (simp add: well_typed_state_def)
     apply (simp add: well_typed_state_def)
    (* - here we type e2 based on our earlier assumption *)
     apply (rule_tac x="rx2" in exI)
     apply (rule_tac x="comp_use_env r_s3 (infl_use_env r_s1 r_s2a)" in exI)
     apply (auto)(*
       (*apply (rule_tac r_c="red_use_env (comp_use_env r_s3 (infl_use_env r_s1 r_s2a)) e2' ax" in well_typed_decr_end_perm)*)
      apply (rule_tac env'="red_env env tau' ax" in well_typed_contain_env)
       apply (rule_tac ex="e2'" in well_typed_red_simul_perm)
        apply (auto)(*
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
          apply (rule_tac well_typed_perm_leq)
          apply (auto)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
        apply (rule_tac self_infl_leq_use_env)
       apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (simp)
       apply (rule_tac comp_leq_use_env2)
       apply (rule_tac self_lift_leq_use_env)*)
      apply (rule_tac exp_contain_env)
      apply (auto)*)
    (* - lastly we prove the various bounds *)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
    (* - end perm bound *)
         apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
          apply (rule_tac unroll_dcl_use_env)
          apply (rule_tac dist_diff_leq_use_env)
          apply (rule_tac unroll_dcl_use_env)
          apply (rule_tac dist_diff_leq_use_env)
          apply (rule_tac rhs_unroll_dcl_use_env)
          apply (rule_tac mini_disj_diff_leq_use_env2)
           apply (rule_tac dist_diff_leq_use_env)
           apply (rule_tac self_comp_leq_use_env1)
          apply (rule_tac gen_mini_disj_use_env1)
          apply (rule_tac comm_disj_use_env)
          apply (rule_tac r_s="r_s3" in disj_leq_use_env1)
           apply (rule_tac infl_disj_use_env)
           apply (rule_tac well_typed_perm_leq)
           apply (auto)
         apply (rule_tac self_diff_leq_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
           apply (simp)
          apply (rule_tac self_comp_leq_use_env1)
         apply (rule_tac self_comp_leq_use_env2)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
         apply (simp)
        apply (rule_tac self_comp_leq_use_env2)
(*
    (* - result used for diff_end_red_leq_use_env_ex lemma *)
           apply (cut_tac s="s1" and r_s="r_s1" and r_x="end_red_use_env r_s2 (AppExp e11 e2') ax" in trans_sub_use_env)
             apply (simp add: valid_use_env_def)
            apply (rule_tac end_red_leq_use_env)
            apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
             apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
              apply (rule_tac well_typed_perm_leq)
              apply (auto)
            apply (rule_tac diff_leq_use_env)
            apply (rule_tac well_typed_perm_leq)
            apply (auto)
    (* - end perm bound *)
           apply (rule_tac rhs_unroll_dcl_use_env)
           apply (rule_tac s="s1" in diff_end_red_leq_use_env_ex)
             apply (auto)
           apply (rule_tac rhs_fold_dcl_use_env)
           apply (rule_tac rhs_flip_use_env)
           apply (rule_tac rhs_unroll_dcl_use_env)
           apply (rule_tac rhs_flip_use_env)
           apply (rule_tac rhs_unroll_dcl_use_env)
           apply (rule_tac s="s1" in diff_end_red_leq_use_env_ex)
             apply (auto)
           apply (rule_tac r_sb="diff_use_env (end_red_use_env r_s3 (AppExp e11 e2') ax) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
            apply (rule_tac r_sb="diff_use_env (end_red_use_env r_s3 (AppExp e11 e2') ax)
                (comp_use_env (comp_use_env (comp_use_env rx1 (infl_use_env r_s1 r_s2a)) (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
             apply (rule_tac lhs_flip_use_env)
             apply (rule_tac lhs_unroll_dcl_use_env)
             apply (rule_tac lhs_flip_use_env)
             apply (rule_tac lhs_unroll_dcl_use_env)
             apply (rule_tac dist_diff_leq_use_env)
             apply (rule_tac dist_diff_leq_use_env_gen)
              apply (rule_tac dist_diff_leq_use_env)
              apply (rule_tac dist_end_red_leq_use_env)
              apply (rule_tac self_comp_leq_use_env1)
             apply (rule_tac dist_lift_leq_use_env)
             apply (rule_tac end_red_leq_use_env)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac unroll_dcl_use_env)
            apply (rule_tac dist_diff_leq_use_env)
            apply (rule_tac unroll_dcl_use_env)
            apply (rule_tac dist_diff_leq_use_env)
            apply (rule_tac rhs_unroll_dcl_use_env)
            apply (rule_tac mini_disj_diff_leq_use_env)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac gen_mini_disj_use_env1)
            apply (rule_tac comm_disj_use_env)
            apply (rule_tac r_s="r_s3" in disj_leq_use_env1)
             apply (rule_tac infl_disj_use_env)
             apply (rule_tac well_typed_perm_leq)
             apply (auto)
            apply (rule_tac diff_leq_use_env)
            apply (rule_tac end_red_leq_use_env)
            apply (rule_tac id_leq_use_env)
           apply (rule_tac diff_end_red_leq_use_env)
           apply (simp)
          apply (rule_tac safe_lift_end_red_use_env)
          apply (simp)*)
    (* - containment bound *)(*
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac dist_end_red_leq_use_env)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
            apply (rule_tac comp_leq_use_env1)
            apply (simp)
           apply (rule_tac self_comp_leq_use_env1)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac r_sb="end_red_use_env (lift_use_env rx2 r) (AppExp e11 e2') ax" in trans_leq_use_env)
          apply (rule_tac dist_end_red_leq_use_env)
          apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (simp)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac lift_end_red_leq_use_env)*)
    (* - disjointness *)
       apply (rule_tac disj_comp_use_env1)
        apply (simp)
       apply (rule_tac comm_disj_use_env)
       apply (rule_tac infl_disj_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
       apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac self_comp_leq_use_env2)
(*
        apply (rule_tac r_s="comp_use_env rx1 (infl_use_env r_s1 r_s2a)" in disj_leq_use_env1)
         apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
          apply (rule_tac disj_comp_use_env1)
           apply (simp)
          apply (rule_tac comm_disj_use_env)
          apply (rule_tac infl_disj_use_env)
          apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
           apply (rule_tac well_typed_perm_leq)
           apply (auto)
          apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
           apply (simp)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac dist_lift_leq_use_env)
         apply (rule_tac end_red_leq_use_env)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac end_red_leq_use_env)
        apply (rule_tac id_leq_use_env)*)
    (* - in-between bound *)(*
       apply (rule_tac dist_end_red_leq_use_env)
       apply (simp)*)
    (* - subtractibility bound *)
      apply (rule_tac red_leq_use_env)
      apply (auto)
    (*
      apply (rule_tac end_red_leq_use_env2)
      apply (simp)*)
    (* - requirements bound *)
     apply (simp add: app_req_def)
     apply (auto)
     apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac lhs_dist_dcl_use_env)
     apply (rule_tac rhs_dist_dcl_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac lhs_dist_dcl_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac unroll_dcl_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac lhs_unroll_dcl_use_env)
       apply (rule_tac self_diff_leq_use_env)
      apply (rule_tac r_sb="diff_use_env (infl_use_env r_s1 r_s2a) (infl_use_env r_s1 r_s2a)" in trans_leq_use_env)
       apply (rule_tac r_sb="empty_use_env" in trans_leq_use_env)
        apply (rule_tac leq_empty_use_env)
       apply (rule_tac diff_infl_leq_use_env)
      apply (rule_tac dist_diff_leq_use_env_gen)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac lhs_unroll_dcl_use_env)
     apply (rule_tac self_diff_leq_use_env)
    (*
     apply (rule_tac r_sb="diff_use_env (end_red_use_env (comp_use_env (comp_use_env rx1 (infl_use_env r_s1 r_s2a)) rx2) (AppExp e11 e2') ax)
              (end_red_use_env (comp_use_env
                (comp_use_env (comp_use_env rx1 (infl_use_env r_s1 r_s2a)) (lift_use_env rx2 r)) r_ex) (AppExp e11 e2') ax)" in trans_leq_use_env)
      apply (rule_tac dist_diff_end_red_leq_use_env)
      apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac lhs_dist_dcl_use_env)
      apply (rule_tac rhs_dist_dcl_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac comp_leq_use_env1)
       apply (rule_tac lhs_dist_dcl_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac unroll_dcl_use_env)
        apply (rule_tac dist_diff_leq_use_env)
        apply (rule_tac unroll_dcl_use_env)
        apply (rule_tac dist_diff_leq_use_env)
        apply (rule_tac lhs_unroll_dcl_use_env)
        apply (rule_tac self_diff_leq_use_env)
       apply (rule_tac r_sb="diff_use_env (infl_use_env r_s1 r_s2a) (infl_use_env r_s1 r_s2a)" in trans_leq_use_env)
        apply (rule_tac r_sb="empty_use_env" in trans_leq_use_env)
         apply (rule_tac leq_empty_use_env)
        apply (rule_tac diff_infl_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac comp_leq_use_env1)
       apply (rule_tac comp_leq_use_env1)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac unroll_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac unroll_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac lhs_unroll_dcl_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac dist_end_red_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac dist_end_red_leq_use_env)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac lhs_unroll_ercl_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac lhs_unroll_ercl_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac lift_end_red_leq_use_envx)
     apply (rule_tac self_comp_leq_use_env2)*)
    (* proving state validity is maintained *)(*
           apply (rule_tac dist_diff_leq_use_env_gen)
            apply (rule_tac id_leq_use_env)
    
           apply (rule_tac rhs_fold_dcl_use_env)
           apply (rule_tac rhs_fold_dcl_use_env)
           apply (rule_tac rhs_flip_use_env)
           apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
           apply (rule_tac rhs_fold_dcl_use_env)
           apply (rule_tac rhs_flip_use_env)
    
          apply (rule_tac id_leq_use_env)
         apply (rule_tac r_s="r_s2a" in mini_disj_leq_use_env2)
          apply (rule_tac mini_disj_infl_use_env)
         apply (rule_tac diff_leq_use_env)
         apply (rule_tac diff_leq_use_env)
         apply (rule_tac diff_leq_use_env)
          apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac comp_leq_use_env1)
         apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
          apply (simp)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac comp_leq_use_env1)
       apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac disj_comp_use_env1)
       apply (simp)
      apply (rule_tac r_s="r_s2a" in disj_leq_use_env2)
       apply (rule_tac disj_infl_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
      apply (rule_tac red_leq_use_env)
     apply (simp)
    apply (simp add: app_req_def)
    apply (auto)
    apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac lhs_dist_dcl_use_env)
    apply (rule_tac rhs_dist_dcl_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac lhs_dist_dcl_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac unroll_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac unroll_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac lhs_unroll_dcl_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (rule_tac r_sb="diff_use_env (infl_use_env r_s1 r_s2a) (infl_use_env r_s1 r_s2a)" in trans_leq_use_env)
      apply (rule_tac r_sb="empty_use_env" in trans_leq_use_env)
       apply (rule_tac leq_empty_use_env)
      apply (rule_tac diff_infl_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac lhs_unroll_dcl_use_env)
    apply (rule_tac self_diff_leq_use_env)*)
    (* - what remains is to prove the initial assumption we made about e2.
       - to start, we have to change the permissions on e12's well typed-ness statement.
    *)
   apply (cut_tac env="env" and ?r_s1.0="r_s2a" and ?r_s2.0="r_s3" and r_ex="infl_use_env r_s1 r_s2a" and e="e12" in well_typed_comp_perms_gen)
     apply (auto)
    apply (rule_tac mini_disj_infl_use_env2)
   apply (cut_tac env="env" and ?r_s1.0="comp_use_env r_s2a (infl_use_env r_s1 r_s2a)" and r_c="r_s1" and
      ?r_s2.0="comp_use_env r_s3 (infl_use_env r_s1 r_s2a)" and e="e12" in well_typed_incr_start_perm)
     apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac lhs_infl_leq_use_env)
    apply (rule_tac id_leq_use_env)
    (* rhs reduct case. in this case, our goal is to apply the safe_app lemma on e2. *)
   apply (case_tac "app_red_exp (s1, e12) ax (s2, e2')")
    apply (cut_tac env="env" and ?r_s1.0="r_s1" and ?e1.0="e12" and ?e2.0="e2'" in safe_app_red_exp_strict)
        apply (auto)
    (* rhs induct case. in this case, our goal is to induct on e2, which we do with a classic coercion lemma *)
   apply (cut_tac env="env" and e="e12" and ?r_s1.0="r_s1" and ?e2.0="e2'" and tau="t1" and ?r_s2.0="comp_use_env r_s3 (infl_use_env r_s1 r_s2a)" and rx="rx2" in sre_coerce)
         apply (auto)
    (* lhs case.
      - we again start by assuming that the lemma holds for e1. this time we don't require any change of permissions beforehand.
    *)
   apply (case_tac "\<exists>tau'. well_typed (red_env env tau' ax) (red_use_env r_s1 ax) e1' (FunTy t1 tau r a) r_s2a rx1 \<and>
                      (\<exists> rs_map'. well_typed_state s2 (red_env env tau' ax) rs_map' \<and> valid_use_env s2 rs_map' (red_use_env r_s1 ax))")
   apply (auto)
    (* - this makes typing e1 straightforward *)
   apply (rule_tac x="tau'" in exI)
   apply (auto)
   apply (rule_tac x="t1" in exI)
   apply (rule_tac x="r" in exI)
   apply (rule_tac x="a" in exI)
   apply (rule_tac x="r_s2a" in exI)
   apply (rule_tac x="rx1" in exI)
   apply (auto)
    (* - this also makes typing e2 straightforward *)
   apply (rule_tac x="rx2" in exI)
   apply (rule_tac x="r_s3" in exI)
   apply (auto)
    apply (rule_tac well_typed_red_vars)
       apply (auto)
    apply (simp add: well_typed_state_def)
    (* - lastly, filling in the existentials is also straightforward *)
   apply (rule_tac x="r_ex" in exI)
   apply (auto)
   apply (rule_tac red_leq_use_env)
   apply (simp)
    (* lhs reduct case. our goal is to again apply the safe app lemma, which we can do without change of permissions *)
  apply (case_tac "app_red_exp (s1, e11) ax (s2, e1')")
   apply (cut_tac env="env" and ?r_s1.0="r_s1" and ?e1.0="e11" and ?e2.0="e1'" in safe_app_red_exp_strict)
       apply (auto)
    (* lhs induct case. lastly we can perform another coercion for the inductive case *)
  apply (cut_tac env="env" and e="e11" and ?r_s1.0="r_s1" and ?e2.0="e1'" and tau="FunTy t1 tau r a" and ?r_s2.0="r_s2a" and rx="rx1" in sre_coerce)
        apply (auto)
  done
    
end